[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GF0604 Procesamiento de datos geográficos 2023-I",
    "section": "",
    "text": "Programa del curso\nLos siguientes documentos contienen el programa del curso, para los grupos 01 y 02, según el formato definido por la Escuela de Geografía de la Universidad de Costa Rica.\n\nGrupo 01\nGrupo 02\n\n\n\nVersiones anteriores del curso\nEste sitio web corresponde al curso impartido durante el primer lectivo de 2023. Para consultar las versiones de otros años y ciclos lectivos, puede visitar:\n\n2022-I\n2021-I\n2020-I\n\n\n\nInformación de contacto\nSi tiene alguna pregunta o comentario sobre este curso, por favor contacte a:\n\nManuel Vargas - manuel.vargas_d@ucr.ac.cr\nProfesor\nUniversidad de Costa Rica,\nCiudad Universitaria Rodrigo Facio,\nSan Pedro de Montes de Oca,\nCosta Rica.\n\nLos contenidos de este curso, a menos que se especifique de otra forma, se comparten mediante una licencia de Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional."
  },
  {
    "objectID": "parte-i-introduccion-programacion_computadoras.html",
    "href": "parte-i-introduccion-programacion_computadoras.html",
    "title": "I - Introducción a la programación de computadoras",
    "section": "",
    "text": "2 Interacción humano-computadora\n3 GDAL - biblioteca para lectura y escritura de datos geoespaciales con interfaz de línea de comandos\n4 Reproducibilidad\n5 Markdown - lenguaje de marcado\n6 Git - sistema de control de versiones"
  },
  {
    "objectID": "01-pensamiento_computacional-arquitectura_computadoras-lenguajes_programacion.html",
    "href": "01-pensamiento_computacional-arquitectura_computadoras-lenguajes_programacion.html",
    "title": "1  Pensamiento computacional, arquitectura de computadoras y lenguajes de programación",
    "section": "",
    "text": "Una computadora es una máquina que ejecuta secuencias de instrucciones, llamadas programas. Los programas reciben datos de entrada, los procesan y generan salidas. Pueden modificarse sin necesidad de alterar los componentes físicos de la computadora.\nLas computadoras ayudan a resolver problemas de muy diversos tipos. El pensamiento computacional es un enfoque para la resolución de problemas basado en conceptos y métodos de las ciencias de la computación. Sus principios fundamentales son:\n\nDescomposición: división de un problema en subproblemas más pequeños.\nReconocimiento de patrones: búsqueda de similitudes en los problemas.\nAbstracción: identificación de la información que se necesita y filtrado de la que no se necesita para resolver un problema.\nAlgoritmos: descripción, paso por paso, de la solución a un problema.\n\nLas computadoras modernas están construídas con base en circuitos integrados (CI), también llamados chips o microchips. Los CI procesan información digital (que usa valores discretos), la cual generalmente es binaria (i.e. de dos valores). Los CI de una computadora procesan dos estados correspondientes a dos niveles de tensión eléctrica: alto y bajo. Estos estados se representan con 0 y 1. Esto facilita la aplicación de la lógica binaria y de la aritmética binaria.\nDurante el período entre las guerras mundiales, Allan Turing desarrolló la máquina de Turing, un dispositivo teórico que manipula símbolos de una cinta de acuerdo con una tabla de reglas. La máquina de Turing simula el funcionamiento de un algoritmo y los conceptos de entrada, procesamiento y salida. En 1945, John von Neumann propuso un concepto conocido como programa almacenado, en el cual los datos y los programas se almacenan en una estructura llamada memoria, separada del hardware que ejecuta las instrucciones. Este esquema permite que las computadoras sean más fáciles de reprogramar y es conocido actualmente como arquitectura de von Neumann.\nEl lenguaje máquina es un conjunto de instrucciones binarias interpretables por la unidad central de procesamiento (CPU) de una computadora. Cada CPU tiene su propio lenguaje máquina. Un programa consiste de una secuencia de instrucciones en lenguaje máquina.\nDebido a que programar una computadora en lenguaje máquina es excesivamente lento y complicado, en la década de 1950 comenzaron a crearse lenguajes de programación que, en lugar de unos y ceros, consisten de instrucciones formadas por palabras, usualmente en idioma inglés. Existe una gran variedad de lenguajes de programación que han sido creados con diversos fines: científicos, comerciales, educacionales y otros.\nScratch es un lenguaje de programación orientado a educación. Fue desarrollado en 2003 por el MIT Media Lab y es administrado por la Fundación Scratch, una organización sin fines de lucro que lo facilita de manera gratuita."
  },
  {
    "objectID": "01-pensamiento_computacional-arquitectura_computadoras-lenguajes_programacion.html#trabajo-previo",
    "href": "01-pensamiento_computacional-arquitectura_computadoras-lenguajes_programacion.html#trabajo-previo",
    "title": "1  Pensamiento computacional, arquitectura de computadoras y lenguajes de programación",
    "section": "1.2 Trabajo previo",
    "text": "1.2 Trabajo previo\n\n1.2.1 Lecturas\nWing, J. M. (2006). Computational thinking. Communications of the ACM, 49(3), 33-35. https://doi.org/10.1145/1118178.1118215"
  },
  {
    "objectID": "01-pensamiento_computacional-arquitectura_computadoras-lenguajes_programacion.html#diapositivas",
    "href": "01-pensamiento_computacional-arquitectura_computadoras-lenguajes_programacion.html#diapositivas",
    "title": "1  Pensamiento computacional, arquitectura de computadoras y lenguajes de programación",
    "section": "1.3 Diapositivas",
    "text": "1.3 Diapositivas\nPensamiento computacional, arquitectura de computadoras y lenguajes de programación"
  },
  {
    "objectID": "02-interaccion_humano_computadora.html",
    "href": "02-interaccion_humano_computadora.html",
    "title": "2  Interacción humano-computadora",
    "section": "",
    "text": "Los humanos interactúan con las computadoras a través de interfaces de tres tipos:\n\nInterfaces de línea de comandos: aceptan líneas de texto correspondientes a comandos o instrucciones.\nInterfaces gráficas de usuario: utilizan objetos gráficos para representar las acciones y la información disponibles en la interfaz.\nInterfaces naturales de usuario: la interacción se realiza a través de movimientos, gestos o voz.\n\nLas interfaces gráficas de usuario y las interfaces naturales de usuario son más intuitivas para los usuarios finales. Sin embargo, las interfaces de línea de comandos son más versátiles y facilitan el desarrollo de soluciones más reproducibles."
  },
  {
    "objectID": "02-interaccion_humano_computadora.html#introducción",
    "href": "02-interaccion_humano_computadora.html#introducción",
    "title": "2  Interacción humano-computadora",
    "section": "2.2 Introducción",
    "text": "2.2 Introducción\nLa interacción humano-computadora (IHC) es un área de investigación dedicada al diseño y uso de la tecnología computacional. Esta interacción se realiza a través de interfaces. La IHC se sitúa en la intersección de varias disciplinas que incluyen ciencias de la computación, ciencias de la conducta, diseño y estudios de medios, entre otras. Los investigadores de IHC estudian la manera en la que los humanos interactúan con las computadoras y diseñan tecnologías para mejorar esa interacción.\nLa IHC enfatiza que, a diferencia de otras máquinas y herramientas con usos más limitados, las computadoras tienen aplicaciones muy diversas que implican un “diálogo” más complejo con los usuarios."
  },
  {
    "objectID": "02-interaccion_humano_computadora.html#interfaces-de-usuario",
    "href": "02-interaccion_humano_computadora.html#interfaces-de-usuario",
    "title": "2  Interacción humano-computadora",
    "section": "2.3 Interfaces de usuario",
    "text": "2.3 Interfaces de usuario\nLa interfaz de usuario es el medio con el que el usuario puede comunicarse con una computadora (o, en general, con cualquier máquina o dispositivo). Las interfaces de usuario se diseñan para que sean fáciles de entender y de utilizar.\nLas interfaces de usuario pueden clasificarse en tres tipos:\n\nInterfaces de línea de comandos (CLI, del inglés, command-line interface).\nInterfaces gráficas de usuario (GUI, del inglés, graphical user interface).\nInterfaces naturales de usuario (NUI, del inglés, natural user interface).\n\nLa evolución de estos tipos de interfaces se ilustra en la Figura 2.1.\n\n\n\n\n\nFigura 2.1: Evolución de las interaces de usuario. Imagen de Marcecoro compartida a través de Wikimedia Commons.\n\n\n\n\n\n2.3.1 Interfaces de línea de comandos\nLas interfaces de línea de comandos (CLI) permiten a los usuarios dar indicaciones a la computadora por medio de líneas de texto correspondientes a comandos o instrucciones. Los comandos pueden introducirse interactivamente en algún tipo de entrada de texto (ej. el prompt de un sistema operativo) o, de manera más automatizada, a través de un archivo (ej. un script). La Figura 2.2 muestra la terminal del sistema operativo Ubuntu, como un ejemplo de CLI.\n\n\n\n\n\nFigura 2.2: Terminal del sistema operativo Ubuntu (Linux).\n\n\n\n\nEste tipo de interfaz existe casi desde los inicios de la computación y es superada en antigüedad solo por las tarjetas perforadas y otros mecanismos similares.\nLas CLI tienen la ventaja de que facilitan el desarrollo de procedimientos reproducibles y repetibles. Por otro lado, puede ser más complejas, especialmente para usuarios no experimentados.\n\n\n2.3.2 Interfaces gráficas de usuario\nLas interfaces gráficas de usuario (GUI) utilizan imágenes y otros objetos gráficos (ej. iconos) para representar la información y las acciones disponibles en la interfaz. Surgieron como una evolución de las CLI. Por ejemplo, muchos sistemas operativos desarrollaron primero sus CLI y luego GUI que permiten realizar acciones equivalentes a los comandos de las CLI. La Figura 2.3 muestra la interfaz gráfica del sistema operativo Ubuntu (Linux).\n\n\n\n\n\nFigura 2.3: Interfaz gráfica GNOME del sistema operativo Ubuntu (Linux).\n\n\n\n\nComo un precursor de las actuales GUI, suele mencionarse una interfaz de hipervículos desarrollada en el Stanford Research Institute, en la década de 1960 (se recomienda ver The Mother of All Demos, presented by Douglas Engelbart (1968)). Este concepto fue ampliado y trasladado a un entorno gráfico por los investigadores del Xerox PARC, en Palo Alto. Ahí se introdujeron conceptos como ventanas, casillas de verificación (checkboxes), botones de radio, menús y puntero del ratón. La interfaz fue implementada comercialmente en el computador Xerox Star 8010, en 1981.\nLas GUI son más amigables e intuitivas que las CLI, pero también pueden ser menos versátiles y menos aptas para reproducir procedimientos.\n\n\n2.3.3 Interfaces naturales de usuario\nEn las interfaces naturales de usuario (NUI), este interactúa con la computadora sin utilizar dispositivos como el ratón o el teclado, sino a través de movimientos, gestos o la voz, como en el caso de las pantallas multitáctiles o del control por reconocimiento del habla. Las NUI no requieren que el usuario aprenda el uso de nuevas tecnologías, ya que puede emplear habilidades ya conocidas. La Figura 2.4 muestra la consola de videojuegos Xbox 360 S, como un ejemplo de dispositivo con NUI.\n\n\n\n\n\nFigura 2.4: Consola Xbox 360 S. Imagen de James Pfaff (litheon) compartida a través de Wikimedia Commons."
  },
  {
    "objectID": "02-interaccion_humano_computadora.html#recursos-de-interés",
    "href": "02-interaccion_humano_computadora.html#recursos-de-interés",
    "title": "2  Interacción humano-computadora",
    "section": "2.4 Recursos de interés",
    "text": "2.4 Recursos de interés\nMarcel. (2012). The Mother of All Demos, presented by Douglas Engelbart (1968). https://www.youtube.com/watch?v=yJDv-zdhzMY"
  },
  {
    "objectID": "03-gdal.html",
    "href": "03-gdal.html",
    "title": "3  GDAL - biblioteca para lectura y escritura de datos geoespaciales con interfaz de línea de comandos",
    "section": "",
    "text": "Geospatial Data Abstraction Library (GDAL) es una biblioteca, desarrollada en C/C++, para la escritura y lectura de datos geoespaciales, tanto raster como vectoriales. Ha sido traducida a otros lenguajes de programación como Java, Python y R. Es utilizada en una gran cantidad de aplicaciones de escritorio, aplicaciones web y bibliotecas para programación. Además, incluye un conjunto de programas que pueden ejecutarse desde la línea de comandos de varios sistemas operativos.\nGDAL implementa un único modelo abstracto de datos raster y un único modelo abstracto de datos vectoriales, lo que permite programar aplicaciones geoespaciales sin tener que ocuparse de las particularidades de cada formato (GeoTIFF, NetCDF, ESRI Shapefile, GeoPackage, GeoJSON, GeoParquet, WMS, WFS, etc.)."
  },
  {
    "objectID": "03-gdal.html#trabajo-previo",
    "href": "03-gdal.html#trabajo-previo",
    "title": "3  GDAL - biblioteca para lectura y escritura de datos geoespaciales con interfaz de línea de comandos",
    "section": "3.2 Trabajo previo",
    "text": "3.2 Trabajo previo\n\n3.2.1 Lecturas\nPebesma, E., Wagner, W., Verbesselt, J., Goor, E., Briese, C., & Neteler, M. (2016). OpenEO: a GDAL for Earth Observation Analytics. https://r-spatial.org/2016/11/29/openeo.html\n\n\n3.2.2 Tutoriales\nGandhi, U. (2020). Mastering GDAL Tools. Spatial Thoughts. https://spatialthoughts.com/courses/mastering-gdal-tools/"
  },
  {
    "objectID": "03-gdal.html#introducción",
    "href": "03-gdal.html#introducción",
    "title": "3  GDAL - biblioteca para lectura y escritura de datos geoespaciales con interfaz de línea de comandos",
    "section": "3.3 Introducción",
    "text": "3.3 Introducción\nGeospatial Data Abstraction Library (GDAL) es una biblioteca para leer y escribir datos geoespaciales en formatos raster y vectoriales. GDAL implementa, entre otras capacidades:\n\nConversiones entre formatos.\nReproyecciones entre sistemas de coordenadas.\nConsultas no espaciales (i.e. en atributos numéricos y textuales).\nConsultas espaciales (cercanía, adyacencia, contención, intersección, etc.).\nFiltrado y agrupación de datos.\nVerificación y corrección de geometrías.\n\nEl manejo de datos vectoriales se implementa en la biblioteca asociada OGR (sigla antes usada para OpenGIS Simple Features Reference Implementation), cuyo código fuente se distribuye conjuntamente con el de GDAL. Por este motivo, a GDAL también se le conoce como GDAL/OGR, en donde GDAL se refiere a la funcionalidad para datos raster y OGR a la funcionalidad para datos vectoriales. En este documento, se utiliza la sigla GDAL para referirse a ambas bibliotecas.\nGDAL utiliza un único modelo abstracto de datos raster y un único modelo abstracto de datos vectoriales, lo que permite programar aplicaciones geoespaciales sin tener que ocuparse de las particularidades de cada formato (GeoTIFF, NetCDF, ESRI Shapefile, GeoPackage, GeoJSON, GeoParquet, WMS, WFS, etc.).\nA pesar de que GDAL está programada en los lenguajes C y C++, cuenta con una interfaz de programación de aplicaciones (API, en inglés, Application Programming Interface) para varios lenguajes de programación incluyendo, además de C y C++, Python, Java y otros. En R, paquetes como sf y terra utilizan el código fuente que comparte GDAL. En esta lista de sofware puede apreciarse la gran cantidad de aplicaciones de escritorio, aplicaciones web y bibliotecas para programación que aprovechan la funcionalidad de GDAL.\nAdemás, GDAL incluye un conjunto de programas para la línea de comandos del sistema operativo cuyas distribuciones binarias están disponibles para varios sistemas operativos, incluyendo Windows, macOS y Linux. Estas API y los programas también están incluídos en la plataforma de ciencia de datos Anaconda, la cual puede instalarse en todos los sistemas operativos mencionados.\nGDAL es distribuida por la Open Source Geospatial Foundation (OSGeo) con una licencia X/MIT."
  },
  {
    "objectID": "03-gdal.html#programas-para-la-línea-de-comandos-del-sistema-operativo",
    "href": "03-gdal.html#programas-para-la-línea-de-comandos-del-sistema-operativo",
    "title": "3  GDAL - biblioteca para lectura y escritura de datos geoespaciales con interfaz de línea de comandos",
    "section": "3.4 Programas para la línea de comandos del sistema operativo",
    "text": "3.4 Programas para la línea de comandos del sistema operativo\nLos programas de GDAL para la línea de comandos del sistema operativo permiten ejecutar tareas de geoprocesamiento y de conversión entre formatos geoespaciales sin utilizar una interfaz gráfica o un lenguaje de programación. Seguidamente, se listan algunos de estos programas.\nProgramas para datos raster\n\ngdalinfo: despliega información sobre un conjunto de datos raster.\ngdaldem: herramientas para visualizar y analizar modelos digitales de elevación.\ngdal_translate: realiza conversiones entre formatos raster.\ngdalwarp: reproyecta datos raster y realiza otras conversiones.\ngdal_calc.py: calculadora de álgebra raster.\n\nProgramas para datos vectoriales\n\nogrinfo: despliega información sobre un conjunto de datos vectorial.\nogr2ogr: realiza conversiones en conjuntos de datos vectoriales (ej. filtros, reproyecciones).\nogrmerge.py: une varios conjuntos de datos raster en uno solo.\nogr_layer_algebra.py: realiza operaciones de álgebra vectorial.\n\nLos programas se ejecutan escribiendo el nombre del programa y un conjunto de opciones que especifican, entre otros aspectos, la ubicación de los datos de entrada, de salida y las transformaciones a realizar. Por ejemplo, el siguiente comando convierte un archivo en formato ESRI Shapefile a GeoJSON y lo reproyecta de CRTM05 a WGS84:\nogrinfo -s_srs EPSG:5367 -t_srs EPSG:4326 provincias.geojson provincias.shp\n\n3.4.1 Comandos básicos del sistema operativo\nLa siguiente lista presenta algunos comandos básicos de sistemas operativos.\n\n3.4.1.1 Windows\n\n\n\n\n\n\nComando\n\n\nDescripción\n\n\nEjemplos\n\n\n\n\n\n\ndir\n\n\nListado de contenidos de un directorio\n\n\ndirdir /wdir /p\n\n\n\n\ncd\n\n\nCambio de directorio\n\n\ncd gf0604\\ejemplos-gdalcd c:\\gf0604\\ejemplos-gdal\n\n\n\n\ncd ..\n\n\nCambio al directorio padre\n\n\ncd ..\n\n\n\n\ncd \\\n\n\nCambio al directorio raíz\n\n\ncd \\\n\n\n\n\nmkdir\n\n\nCreación de un directorio\n\n\nmkdir mi-directorio\n\n\n\n\nrmdir\n\n\nBorrado de un directorio\n\n\nrmdir /s mi-directorio\n\n\n\n\ntype\n\n\nDespliegue de los contenidos de un archivo de texto\n\n\ntype mi-archivo.txt\n\n\n\n\ndel\n\n\nBorrado de un archivo\n\n\ndel mi-archivo.txt\n\n\n\n\n> salida.txt\n\n\nRedireccionamiento de la salida\n\n\ndir /b > directorio.txt\n\n\n\n\ncls\n\n\nBorrado de la pantalla\n\n\ncls\n\n\n\n\n\n\n\n\n3.4.2 Instalación\nEn el sitio web de GDAL se describen varias opciones para la descarga e instalación de los programas para la línea de comandos del sistema operativo, incluyendo archivos binarios ejecutables para varias plataformas.\nEn el caso del sistema operativo Windows, estos programas se incluyen en la aplicación OSGeo4W, la cual puede instalarse junto con el sistema de información geográfica de escritorio QGIS. Se recomienda usar el instalador de red OSGeo4W. Una vez finalizada la instalación, verifique que cuenta con la aplicación OSGeo4W Shell para ejecutar los programas desde la línea de comandos del sistema operativo.\n\n\n3.4.3 Opciones comunes\nLos programas de GDAL comparten una serie de opciones comunes para datos raster y de opciones comunes para datos vectoriales que pueden visualizarse con la opción -- help-general. Por ejemplo:\nogrinfo --help-general\nGeneric GDAL utility command options:\n  --version: report version of GDAL in use.\n  --license: report GDAL license info.\n  --formats: report all configured format drivers.\n  --format [format]: details of one format.\n  --optfile filename: expand an option file into the argument list.\n  --config key value: set system configuration option.\n  --debug [on/off/value]: set debug level.\n  --pause: wait for user input, time to attach debugger\n  --locale [locale]: install locale for debugging (i.e. en_US.UTF-8)\n  --help-general: report detailed help on general options.\nPara obtener ayuda acerca de un comando particular, puede usarse la opción -- help. Por ejemplo:\nogrinfo --help\nUsage: ogrinfo [--help-general] [-ro] [-q] [-where restricted_where|@filename]\n               [-spat xmin ymin xmax ymax] [-geomfield field] [-fid fid]\n               [-sql statement|@filename] [-dialect sql_dialect] [-al] [-rl] [-so] [-fields={YES/NO}]\n               [-geom={YES/NO/SUMMARY}] [[-oo NAME=VALUE] ...]\n               [-nomd] [-listmdd] [-mdd domain|`all`]*\n               [-nocount] [-noextent] [-nogeomtype] [-wkt_format WKT1|WKT2|...]\n               [-fielddomain name]\n               datasource_name [layer [layer ...]]\n\n\n3.4.4 Ejemplos de uso\nEn esta sección, se presentan ejemplos de uso de los programas, tanto para datos vectoriales como para datos raster.\n\n3.4.4.1 Programas para datos vectoriales\n\n3.4.4.1.1 ogrinfo\nEl programa ogrinfo despliega información acerca de una fuente de datos vectoriales.\nLos siguientes comandos despliegan información sobre la capa de países de Natural Earth, tanto para el formato comprimido (ZIP) como para el formato shapefile (SHP). En el caso comprimido, note el uso del prefijo /vsizip/, para sistemas de archivos virtuales.\n\nCree un nuevo directorio (ej. ejemplos-gdal) para almacenar los archivos con los que trabajará.\nDescargue en el nuevo directorio la capa de paises desde la dirección https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/110m/cultural/ne_110m_admin_0_countries.zip.\nDescomprima el archivo ZIP (no lo borre).\nCon una herramienta de escritorio (ej. QGIS), visualice tanto el archivo ZIP como el SHP.\nDesde una interfaz de línea de comandos (ej. OSGeo4W Shell), ubíquese en el directorio que creó y ejecute los siguientes comandos para obtener información sobre ambos archivos:\n\n# Información sobre la capa descomprimida en formato shapefile\nogrinfo -al -so ne_110m_admin_0_countries.shp\n\n# Información sobre la capa comprimida en formato ZIP\nogrinfo -al -so /vsizip/ne_110m_admin_0_countries.zip\n¿Qué información despliegan ambos comandos? ¿Qué efectos produce el uso de las opciones -al y -so? Revise la documentación sobre estas opciones y pruebe los comandos omitiendo cada una y ambas.\n\nFiltre los registros con expresiones lógicas (booleanas).\n\n# Registros (países y otros territorios) del continente 'Oceania' (se omite el campo de la geometría)\nogrinfo -al -where \"CONTINENT='Oceania'\" -geom=NO ne_110m_admin_0_countries.shp\n\n# Registros de Oceanía de tipo país ('Country')\nogrinfo -al -where \"CONTINENT='Oceania' AND TYPE='Country'\" -geom=NO ne_110m_admin_0_countries.shp\nNote el uso del operador AND (y), el cuál es un operador lógico, como también lo son el OR (o) y el NOT (no).\n\nAplique los filtros anteriores desde la interfaz de QGIS y compare las ventajas y desventajas de cada enfoque.\n\n\n\n3.4.4.1.2 ogr2ogr\nEl programa ogr2ogr realiza conversiones entre formatos de fuentes de datos vectoriales. A la vez, puede ejecutar otras operaciones como selección de atributos y geometrías, filtrado por criterios espaciales y no espaciales, reproyección y validación de geometrías, entre otras.\n\nDespliegue la lista de formatos (drivers) vectoriales soportados por OGR:\n\n# Despliegue de la lista de formatos vectoriales soportados por GDAL/OGR\nogr2ogr --formats\nSupported Formats:\n  FITS -raster,vector- (rw+): Flexible Image Transport System\n  PCIDSK -raster,vector- (rw+v): PCIDSK Database File\n  netCDF -raster,multidimensional raster,vector- (rw+vs): Network Common Data Format\n  PDS4 -raster,vector- (rw+vs): NASA Planetary Data System 4\n  VICAR -raster,vector- (rw+v): MIPL VICAR file\n  JP2OpenJPEG -raster,vector- (rwv): JPEG-2000 driver based on OpenJPEG library\n  PDF -raster,vector- (rw+vs): Geospatial PDF\n  MBTiles -raster,vector- (rw+v): MBTiles\n  BAG -raster,multidimensional raster,vector- (rw+v): Bathymetry Attributed Grid\n  EEDA -vector- (ro): Earth Engine Data API\n  OGCAPI -raster,vector- (rov): OGCAPI\n  ESRI Shapefile -vector- (rw+v): ESRI Shapefile\n...\n\nEjecute los siguientes comandos para convertir la capa de países (en SHP) a otros formatos y cambiar su nombre:\n\n# Conversión de SHP a GeoJSON\nogr2ogr paises.geojson ne_110m_admin_0_countries.shp\n\n# Conversión de SHP a GeoPackage\nogr2ogr paises.gpkg ne_110m_admin_0_countries.shp\n\nDespliegue la lista de capas en el servicio WFS del Sistema Nacional de Áreas de Conservación (Sinac):\n\n# Lista de capas en el servicio WFS del Sinac\nogrinfo WFS:\"http://geos1pne.sirefor.go.cr/wfs\"\nINFO: Open of `WFS:http://geos1pne.sirefor.go.cr/wfs'\n      using driver `WFS' successful.\nMetadata:\n  ABSTRACT=Servicio de mapas de Patrimonio Natural del Estado.\n  PROVIDER_NAME=The ancient geographes INC\n  TITLE=PNE Web Map Service\n1: PNE:bosque_decidio (title: Bosque Deciduo)\n2: PNE:bosque_maduro (title: Bosque Maduro)\n3: PNE:bosque_secundario (title: Bosque Secundario)\n4: PNE:bosque_palmas (title: Bosque de Palmas)\n5: PNE:corredoresbiologicos (title: Corredores Biológicos)\n6: PNE:patrimonio_natural_del_estado (title: Patrimonio Natural del Estado)\n7: PNE:registro_nacional_humedales (title: Registro Nacional de Humedales)\n8: PNE:areas_silvestres_protegidas (title: Áreas Silvestres Protegidas)\n9: PNE:areas_conservacion (title: Áreas de Conservación)\n\nDescargue la capa de áreas silvestres protegidas (ASP) del servicio WFS del Sinac en formato GeoPackage:\n\n# Descarga y validación de geometrías\nogr2ogr -makevalid asp.gpkg WFS:\"http://geos1pne.sirefor.go.cr/wfs\" \"PNE:areas_silvestres_protegidas\"\n\n# Descarga, validación de geometrías y reproyección a WGS84\nogr2ogr -t_srs EPSG:4326 -makevalid asp-wgs84.gpkg WFS:\"http://geos1pne.sirefor.go.cr/wfs\" \"PNE:areas_silvestres_protegidas\"\n\n\n\n3.4.4.2 Programas para datos raster\n\n3.4.4.2.1 gdalinfo\nEl programa gdalinfo despliega información acerca de una fuente de datos raster.\nLos siguientes comandos trabajan con la capa global de altitud de la base de datos climática WorldClim.\n\nDescargue en su directorio de trabajo la capa de altitud, con resolución de 30 segundos. Si la descarga toma demasiado tiempo, puede utilizar otras resoluciones: 2.5 min, 5 min o 10 min.\nDescomprima el archivo ZIP.\nCon una herramienta de escritorio (ej. QGIS), visualice la capa descomprimida.\nDesde una interfaz de línea de comandos (ej. OSGeo4W Shell), ubíquese en su directorio de trabajo y ejecute los siguientes comandos para obtener información sobre la capa:\n\n# Información sobre la capa\ngdalinfo -stats wc2.1_30s_elev.tif\nDriver: GTiff/GeoTIFF\nFiles: wc2.1_30s_elev.tif\nSize is 43200, 21600\nCoordinate System is:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\nData axis to CRS axis mapping: 2,1\nOrigin = (-180.000000000000000,90.000000000000000)\nPixel Size = (0.008333333333333,-0.008333333333333)\nMetadata:\n  AREA_OR_POINT=Area\nImage Structure Metadata:\n  COMPRESSION=DEFLATE\n  INTERLEAVE=BAND\nCorner Coordinates:\nUpper Left  (-180.0000000,  90.0000000) (180d 0' 0.00\"W, 90d 0' 0.00\"N)\nLower Left  (-180.0000000, -90.0000000) (180d 0' 0.00\"W, 90d 0' 0.00\"S)\nUpper Right ( 180.0000000,  90.0000000) (180d 0' 0.00\"E, 90d 0' 0.00\"N)\nLower Right ( 180.0000000, -90.0000000) (180d 0' 0.00\"E, 90d 0' 0.00\"S)\nCenter      (   0.0000000,   0.0000000) (  0d 0' 0.01\"E,  0d 0' 0.01\"N)\nBand 1 Block=43200x1 Type=Int16, ColorInterp=Gray\n  Min=-415.000 Max=8424.000 \n  Minimum=-415.000, Maximum=8424.000, Mean=nan, StdDev=nan\n  NoData Value=-32768\n  Metadata:\n    STATISTICS_MAXIMUM=8424\n    STATISTICS_MEAN=1.#SNAN\n    STATISTICS_MINIMUM=-415\n    STATISTICS_STDDEV=1.#SNAN\n\n\n3.4.4.2.2 gdalwarp\nEl programa gdalwarp se utiliza para reproyectar y transformar datos raster.\n\nRecorte la capa raster de altitud global con el contorno de la capa de cantones de Costa Rica y reproyección a CRTM05:\n\n# Recorte de la capa raster de altitud global con el contorno de la capa de cantones de Costa Rica\ngdalwarp -dstnodata -9999 -tr 0.00833333 0.00833333 -q -cutline cantones-wgs84.gpkg -crop_to_cutline wc2.1_30s_elev.tif altitud-cr-wgs84.tif\n\n# Información sobre la capa de altitud de Costa Rica\ngdalinfo -stats altitud-cr-wgs84.tif\n\n# Reproyección a CRTM05\ngdalwarp -s_srs EPSG:4326 -t_srs EPSG:5367 altitud-cr-wgs84.tif altitud-cr-crtm05.tif\n\n\n3.4.4.2.3 gdaldem\nEl programa gdaldem contiene un conjunto de herramientas para visualizar y analizar modelos digitales de elevación (DEM, en inglés, Digital Elevation Model).\n\nCree un mapa con efecto de relieve (hillshade) a partir de la capa de altitud de Costa Rica en el sistema de coordenadas WGS84.\n\n# Mapa hillshade\ngdaldem hillshade altitud-cr-wgs84.tif altitud-cr-wgs84-hillshade.tif -s 111120\nEl resultado se muestra en la Figura 3.1.\n\n\n\n\n\nFigura 3.1: Mapa de Costa Rica con efecto de relieve (hillshade).\n\n\n\n\n\nCree un mapa con efecto de relieve (hillshade) multidireccional a partir de la capa de altitud de Costa Rica en el sistema de coordenadas WGS84.\n\n# Mapa hillshade multidireccional\ngdaldem hillshade altitud-cr-wgs84.tif altitud-cr-wgs84-hillshade-multidireccional.tif -s 111120 -multidirectional\nEl resultado se muestra en la Figura 3.2.\n\n\n\n\n\nFigura 3.2: Mapa de Costa Rica con efecto de relieve (hillshade) multidireccional.\n\n\n\n\n\nCree un mapa coloreado de relieve a partir de la capa de altitud de Costa Rica en el sistema de coordenadas WGS84.\n\n\nCree un archivo llamado colores.txt con el siguiente contenido:\n\nnv,255,255,255\n500,101,146,82\n1000,190,202,130\n1500,241,225,145\n2000,244,200,126\n2500,197,147,117\n3000,204,169,170\n4000,251,238,253\nLas columnas del archivo corresponden a altitud, rojo, verde, azul.\n\nEjecute el siguiente comando:\n\n# Mapa coloreado de relieve\ngdaldem color-relief altitud-cr-wgs84.tif colores.txt altitud-cr-wgs84-colores.tif\nEl resultado se muestra en la Figura 3.3.\n\n\n\n\n\nFigura 3.3: Mapa coloreado de relieve de Costa Rica."
  },
  {
    "objectID": "03-gdal.html#ejercicios",
    "href": "03-gdal.html#ejercicios",
    "title": "3  GDAL - biblioteca para lectura y escritura de datos geoespaciales con interfaz de línea de comandos",
    "section": "3.5 Ejercicios",
    "text": "3.5 Ejercicios\n\n3.5.1 Datos vectoriales\n\nDe la capa de países de Natural Earth, extraiga los registros con población estimada superior a mil millones. En la capa resultante, incluya solamente los campos de nombre del país en español y población estimada. ¿Cuál opción debe utilizar para especificar los campos que desea incluir en el archivo de salida?\nDe la capa de ASP de Costa Rica, extraiga en un archivo GeoJSON las ASP del Área de Conservación Central.\nDe la capa de ASP de Costa Rica, extraiga en un archivo GeoJSON las ASP terrestres con área mayor o igual a 1000 km2.\nDe la capa de ASP de Costa Rica, extraiga en un archivo GeoJSON las ASP terrestres con área mayor o igual a 500 km2 del Área de Conservación Central.\nDe la capa de ASP de Costa Rica, extraiga en un archivo GeoJSON las ASP terrestres con área mayor o igual a 500 km2 de las áreas de conservación Central, Tortuguero y Osa.\nDe la capa de ASP de Costa Rica, extraiga en un archivo GeoPackage, las ASP del Área de Conservación Guanacaste, excepto el Parque Nacional Santa Rosa.\n\n\n\n3.5.2 Datos raster\n\nRecorte la capa de altitud de Costa Rica de acuerdo con el contorno de la provincia de Limón y extraiga el resultado en nuevo archivo GeoTIFF.\nGenere un mapa con efecto de relieve (hillshade) para la provincia de Limón. 3- Genere un mapa coloreado de relieve para la provincia de Limón."
  },
  {
    "objectID": "03-gdal.html#recursos-de-interés",
    "href": "03-gdal.html#recursos-de-interés",
    "title": "3  GDAL - biblioteca para lectura y escritura de datos geoespaciales con interfaz de línea de comandos",
    "section": "3.6 Recursos de interés",
    "text": "3.6 Recursos de interés\nCodecademy. (s. f.). Command Line Tutorial: Learn The Command Line. Codecademy. Recuperado 19 de marzo de 2022, de https://www.codecademy.com/learn/learn-the-command-line\nSS64 Command line reference. (s. f.). Recuperado 3 de abril de 2022, de https://ss64.com/"
  },
  {
    "objectID": "04-reproducibilidad.html",
    "href": "04-reproducibilidad.html",
    "title": "4  Reproducibilidad",
    "section": "",
    "text": "Un análisis realizado por un investigador se considera reproducible si el código fuente y los datos que utilizó para obtener los resultados están disponibles y son suficientes para que otro investigador, trabajando de manera independiente, pueda llegar al mismo resultado. El concepto de reproducibilidad es cada vez más importante debido al aumento exponencial de datos y al empleo de la programación de computadoras por parte de especialistas de diversas disciplinas."
  },
  {
    "objectID": "04-reproducibilidad.html#introducción",
    "href": "04-reproducibilidad.html#introducción",
    "title": "4  Reproducibilidad",
    "section": "4.2 Introducción",
    "text": "4.2 Introducción\nEn general, la reproducibilidad es la capacidad de un ensayo o experimento de ser reproducido por otros. Más formalmente, en investigación cuantitativa, un análisis se considera reproducible si “el código fuente y los datos utilizados por un investigador para llegar a un resultado están disponibles y son suficientes para que otro investigador, trabajando de manera independiente, pueda llegar al mismo resultado” (Gandrud 2020).\nLa reproducibilidad, junto con la falsabilidad, es uno de los pilares del método científico. Sin embargo, en años recientes, se ha generado una creciente preocupación debido a que muchos estudios científicos publicados fallan las pruebas de reproducibilidad (véase, por ejemplo, The Excel Depression, de Paul Krugman, Growth in a Time of Debt), dando lugar a una crisis de reproducibilidad o replicabilidad en varias ciencias.\nEl concepto de reproducibilidad es cada vez más importante debido, entre otras razones, al aumento exponencial de datos disponibles y a la aplicación de la programación de computadoras, para procesar estos datos, por parte de especialistas de muchas disciplinas."
  },
  {
    "objectID": "04-reproducibilidad.html#reproducibilidad-en-ciencia-de-datos-geoespaciales",
    "href": "04-reproducibilidad.html#reproducibilidad-en-ciencia-de-datos-geoespaciales",
    "title": "4  Reproducibilidad",
    "section": "4.3 Reproducibilidad en ciencia de datos geoespaciales",
    "text": "4.3 Reproducibilidad en ciencia de datos geoespaciales\nAlex Singleton y otros autores (Singleton, Spielman, y Brunsdon 2016) han identificado los siguientes retos para la reproducibilidad en ciencia de datos geoespaciales:\n\nLos datos deben ser de dominio público y estar disponibles para los investigadores.\nEl software utilizado debe ser de código abierto (open source) y estar disponible para ser revisado.\nSiempre que sea posible, los flujos de trabajo deben ser públicos y con enlaces a los datos, software y métodos de análisis, junto con la documentación necesaria.\nEl proceso de revisión por pares (peer review process) y la publicación académica deben requerir la presentación de un modelo de flujo de trabajo e idealmente la disponibilidad de los materiales necesarios para la replicación.\nEn los casos en los que la reproducibilidad total no sea posible (ej. datos sensibles), los investigadores deben esforzarse por incluir todos los aspectos que puedan de un marco de trabajo abierto.\n\nEn general, el estándar mínimo de reproducibilidad requiere que los datos y el código fuente estén disponibles para otros investigadores (Peng 2011). Sin embargo, dependiendo de las circunstancias y recursos disponibles, existe todo un espectro de posibilidades, que se ilustra en la Figura 4.1.\n\n\n\n\n\nFigura 4.1: Espectro de reproducibilidad. Imagen de Anita Graser, basada en (Peng, 2001)."
  },
  {
    "objectID": "04-reproducibilidad.html#herramientas-para-facilitar-la-reproducibilidad",
    "href": "04-reproducibilidad.html#herramientas-para-facilitar-la-reproducibilidad",
    "title": "4  Reproducibilidad",
    "section": "4.4 Herramientas para facilitar la reproducibilidad",
    "text": "4.4 Herramientas para facilitar la reproducibilidad\nLa documentación es vital durante todo el ciclo de vida de una investigación reproducible. Se recomienda utilizar mecanismos estandarizados y abiertos como el lenguaje de marcado de hipertexto (HTML, en inglés, HyperText Markup Language) o Markdown, con los cuales pueden crearse documentos mediante editores de texto simples (i.e. no se requiere de software propietario), y exportables a varios formatos (ej. LaTeX, PDF).\nPara dar mantenimiento, tanto al código fuente como a la documentación, es necesario un sistema de control de versiones como Git, el cual permite llevar el registro de los cambios en archivos y también facilita el trabajo colaborativo al reunir las modificaciones hechas por varias personas. Git es usado en varias plataformas que comparten código fuente (ej. GitHub, GitLab) y que ofrecen servicios relacionados, como hospedaje de sitios web."
  },
  {
    "objectID": "04-reproducibilidad.html#recursos-de-interés",
    "href": "04-reproducibilidad.html#recursos-de-interés",
    "title": "4  Reproducibilidad",
    "section": "4.5 Recursos de interés",
    "text": "4.5 Recursos de interés\nBartomeus Lab. (2016). A reproducible workflow. https://www.youtube.com/watch?v=s3JldKoA0zw\nFOSS4G. (2021). FOSS4G2021—Open source for open spatial data science—Anita Graser. https://www.youtube.com/watch?v=ZjXb53pOor0\nKrugman, P. (2013). Opinion | The Excel Depression. The New York Times. https://www.nytimes.com/2013/04/19/opinion/krugman-the-excel-depression.html"
  },
  {
    "objectID": "04-reproducibilidad.html#referencias",
    "href": "04-reproducibilidad.html#referencias",
    "title": "4  Reproducibilidad",
    "section": "4.6 Referencias",
    "text": "4.6 Referencias\n\n\nGandrud, Christopher. 2020. Reproducible Research with\nR and RStudio. Third edition. The\nR Series. Boca Raton, FL: CRC Press.\n\n\nPeng, Roger D. 2011. “Reproducible Research in\nComputational Science.”\nScience 334 (6060): 1226–27. https://doi.org/10.1126/science.1213847.\n\n\nSingleton, Alex David, Seth Spielman, and Chris Brunsdon. 2016.\n“Establishing a Framework for Open\nGeographic Information Science.”\nInternational Journal of Geographical Information Science 30\n(8): 1507–21. https://doi.org/10.1080/13658816.2015.1137579."
  },
  {
    "objectID": "05-markdown.html",
    "href": "05-markdown.html",
    "title": "5  Markdown - lenguaje de marcado",
    "section": "",
    "text": "Markdown es un lenguaje de marcado ligero ampliamente utilizado en comunicación científica, documentación de programas e investigación reproducible, entre otras aplicaciones. Incluye marcas para especificar aspectos de estructura, semántica y estilo de un documento. Se basa en texto simple y se convierte fácilmente a HTML, el lenguaje de marcado más utilizado en páginas web.\nMarkdown puede emplearse junto con lenguajes de programación (ej. R, Python) para así combinar texto con código fuente, el cual inserta en los documentos salidas como tablas, gráficos y mapas, entre otras. Esta forma de trabajo facilita la automatización y la reproducibilidad de una investigación."
  },
  {
    "objectID": "05-markdown.html#trabajo-previo",
    "href": "05-markdown.html#trabajo-previo",
    "title": "5  Markdown - lenguaje de marcado",
    "section": "5.2 Trabajo previo",
    "text": "5.2 Trabajo previo\n\n5.2.1 Instalación de software\nPara la edición de código Markdown, en el contexto de la programación en R, se recomienda instalar:\n\nSistema base del lenguaje R (no es necesario para este capítulo, pero sí se utilizará más adelante)\nRStudio Desktop\n\nOpcionalmente, puede instalar Visual Studio Code u otro editor de código fuente.\n\n\n5.2.2 Tutoriales\n\nMarkdown Tutorial"
  },
  {
    "objectID": "05-markdown.html#introducción",
    "href": "05-markdown.html#introducción",
    "title": "5  Markdown - lenguaje de marcado",
    "section": "5.3 Introducción",
    "text": "5.3 Introducción\nMarkdown es un lenguaje de marcado, creado en 2004 por John Gruber y Aaron Swartz. Las “marcas” se utilizan para especificar aspectos de la estructura (ej. títulos, encabezados), estilo (ej. negritas, itálicas) y semántica de un documento. Markdown se caracteriza por ser más sencillo de leer y de usar que otros lenguajes de marcado (ej. Lenguaje de Marcado de Hipertexto o HTML), por lo que se considera un lenguaje de marcado ligero.\nLos documentos escritos en Markdown pueden exportarse a una gran variedad de formatos (ej. HTML, DOC, PDF, LaTex) para ser usados en libros, presentaciones o páginas web, entre otros fines.\n\n5.3.1 Variaciones\nLas variaciones de Markdown, también llamadas flavors, son extensiones o modificaciones de la especificación original. Entre las más populares están:\n\nR Markdown: para el lenguaje R.\nQuarto: es la “siguiente generación” de R Markdown, con soporte para más lenguajes de programación (Python, Julia, Observable, R) y motores de procesamiento (Jupyter, Knitr), entre otras mejoras.\nPython Markdown: para el lenguaje Python.\nGitHub Flavored Markdown: para la plataforma GitHub.\nPandoc’s Markdown: para el programa Pandoc de conversión entre formatos.\nKramdown: para el lenguaje Ruby.\n\nPuede encontrarse una lista más extensa de variaciones de Markdown en Markdown Flavors."
  },
  {
    "objectID": "05-markdown.html#ejemplo-de-documento",
    "href": "05-markdown.html#ejemplo-de-documento",
    "title": "5  Markdown - lenguaje de marcado",
    "section": "5.4 Ejemplo de documento",
    "text": "5.4 Ejemplo de documento\nEl siguiente es un ejemplo de la sintaxis de Markdown, con marcas para un encabezado, texto en negrita, texto en itálica, un hipervínculo y una imagen.\n\n### Los satélites galileanos\n\nSe llaman **satélites galileanos** los cuatro satélites\nde Júpiter descubiertos en 1610 por \n[Galileo Galilei](https://es.wikipedia.org/wiki/Galileo_Galilei): \n*Ío*, *Europa*, *Ganimedes* y *Calisto*. \nSon los más grandes de los satélites de Júpiter, \nsiendo visibles incluso con telescopios de baja potencia.\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Jupiter_and_the_Galilean_Satellites.jpg/168px-Jupiter_and_the_Galilean_Satellites.jpg)\n\n**Figura 1**. Los cuatro satélites galileanos, \nen una composición que compara sus tamaños con el tamaño de Júpiter. \nEn orden descendente, son *Ío*, *Europa*, *Ganimedes* y *Calisto*.\n\nY la siguiente es la manera en la que se visualiza el documento:\n\n\nLos satélites galileanos\nSe llaman satélites galileanos los cuatro satélites de Júpiter descubiertos en 1610 por Galileo Galilei: Ío, Europa, Ganimedes y Calisto. Son los más grandes de los satélites de Júpiter, siendo visibles incluso con telescopios de baja potencia.\n\nFigura 1. Los cuatro satélites galileanos, en una composición que compara sus tamaños con el tamaño de Júpiter. En orden descendente, son Ío, Europa, Ganimedes y Calisto.\n\nEl contenido de este ejemplo fue tomado de Satélite galileano - Wikipedia, la enciclopedia libre."
  },
  {
    "objectID": "05-markdown.html#herramientas-para-escritura-de-documentos",
    "href": "05-markdown.html#herramientas-para-escritura-de-documentos",
    "title": "5  Markdown - lenguaje de marcado",
    "section": "5.5 Herramientas para escritura de documentos",
    "text": "5.5 Herramientas para escritura de documentos\nMarkdown se escribe en “texto simple o plano” (i.e. texto sin formato, compuesto únicamente por caracteres que son legibles por humanos), por lo que puede escribirse con cualquier editor de texto. Se recomienda el uso de editores orientados a programación, también llamados editores de código fuente, los cuales proporcionan facilidades para el programador, como coloración de palabras clave, sangrado y autocompletado, entre otras.\nTambién pueden utilizarse Entornos Integrados de Desarrollo o IDE, los cuales son aplicaciones informáticas que proporcionan servicios integrales para facilitarle al programador el desarrollo de software. Además de un editor de código fuente, un IDE incluye funciones para depuración (i.e. identificación de errores), interpretación y compilación de programas, entre otras.\nAlgunos de los editores de código fuente o IDE recomendados para Markdown son:\n\nVisual Studio Code: editor de código fuente muy popular y de código abierto. Puede editar código de múltiples lenguajes de programación y sintaxis asociadas\nRStudio Desktop: IDE para desarrollo en el lenguaje de programación R, el cual también puede manejar código en otros lenguajes de programación y sintaxis.\n\nNo se recomienda el uso de procesadores de texto (ej. Microsoft Word, Libre Office Writer), debido a que introducen caracteres especiales que no son reconocidos por Markdown."
  },
  {
    "objectID": "05-markdown.html#sintaxis",
    "href": "05-markdown.html#sintaxis",
    "title": "5  Markdown - lenguaje de marcado",
    "section": "5.6 Sintaxis",
    "text": "5.6 Sintaxis\nEn esta sección, se muestran los principales elementos de sintaxis de Markdown y sus salidas.\n\n\n\n5.6.1 Encabezados\nHay seis niveles de encabezados en Markdown, siendo el nivel 1 el de letras más grandes y el 6 el de letras más pequeñas. Se especifican mediante símbolos de numeral (#) antes del texto del encabezado (note el espacio entre el último signo de numeral y el inicio del texto).\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n# Encabezado de nivel 1\n\n\n\nEncabezado de nivel 1\n\n\n\n\n\n## Encabezado de nivel 2\n\n\n\nEncabezado de nivel 2\n\n\n\n\n\n### Encabezado de nivel 3\n\n\n\nEncabezado de nivel 3\n\n\n\n\n\n#### Encabezado de nivel 4\n\n\n\nEncabezado de nivel 4\n\n\n\n\n\n##### Encabezado de nivel 5\n\n\n\nEncabezado de nivel 5\n\n\n\n\n\n###### Encabezado de nivel 6\n\n\n\nEncabezado de nivel 6\n\n\n\n\n\nPara los encabezados de nivel 1 y nivel 2, existe una sintaxis alterna, con símbolos de igual (=====) o guiones (-----) bajo el texto del encabezado.\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nOtro encabezado de nivel 1 ==========================\n\n\n\n\nOtro encabezado de nivel 1\n\n\n\n\n\nOtro encabezado de nivel 2 --------------------------\n\n\n\nOtro encabezado de nivel 2\n\n\n\n\n\n\n\n5.6.2 Párrafos\nLos párrafos deben separarse mediante (al menos) una línea en blanco. Un simple cambio de línea no generará un nuevo párrafo.\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\n\n\n\n\n5.6.3 Negrita\nHay dos sintaxis para especificar texto en negrita: con dos asteriscos (**) o con dos guiones bajos (__), antes y después del texto.\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n**Texto en negrita**\n\n\nTexto en negrita\n\n\n\n\n__Otro texto en negrita__\n\n\nOtro texto en negrita\n\n\n\n\n\n\n5.6.4 Itálica\nHay dos sintaxis para especificar texto en itálica: con un asterisco (*) o con un guión bajo (_), antes y después del texto.\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n*Texto en itálica*\n\n\nTexto en itálica\n\n\n\n\n_Otro texto en itálica_\n\n\nOtro texto en itálica\n\n\n\n\n\n\n5.6.5 Citas textuales\nSe especifican con un símbolo de “mayor que” (>) antes de cada línea.\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n> *And on the pedestal these words appear:* > *\"My name is Ozymandias, king of kings:* > *Look on my works, ye Mighty, and despair!\"* *Percy Bysshe Shelley, \"Ozymandias\" (1818)*\n\n\n\n “And on the pedestal these words appear:”My name is Ozymandias, king of kings: Look on my works, ye Mighty, and despair!“ \n\nPercy Bysshe Shelley, “Ozymandias” (1818)\n\n\n\n\n\n\n5.6.6 Enlaces (hipervínculos)\nSe definen con paréntesis cuadrados ([]) seguidos de paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) el texto del enlace y en los redondos la dirección del documento al que conduce el enlace.\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n[Proyecto Gutenberg](https://www.gutenberg.org/)\n\n\nProyecto Gutenberg\n\n\n\n\n\n\n5.6.7 Imágenes\nSe definen con un signo de admiración de cierre (!), paréntesis cuadrados ([]) y paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) un texto alternativo de la imagen y en los redondos la dirección de la imagen, ya sea local o remota.\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n![Imagen local](img/Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\n\n![Imagen remota](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Jupiter_and_the_Galilean_Satellites.jpg/168px-Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\n\n\n\n5.6.8 Listas numeradas\nSe definen con números (1. 2. 3. ...) antes de cada elemento.\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n1. Primer elemento.\n2. Segundo elemento.\n3. Tercer elemento.\n\n\n\n\nPrimer elemento.\nSegundo elemento.\nTercer elemento.\n\n\n\n\n\n\n\n5.6.9 Listas no numeradas\nSe definen con guiones (-) o asteriscos (*) antes de cada elemento.\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n- Un elemento.\n- Otro elemento.\n- Otro elemento más.\n\n\n\n\nUn elemento.\n\nOtro elemento.\n\nOtro elemento más.\n\n\n\n\n\n\n\n\n5.6.10 Ecuaciones\nLas ecuaciones se escriben con base en la sintaxis de LaTeX. Se delimitan (al inicio y al final) con:\n\nUn símbolo de dólar ($), para ecuaciones dentro de un renglón (inline math).\nDos símbolos de dólar ($$), para ecuaciones en su propio bloque (display math).\n\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEquivalencia entre masa y energía: $E = mc^{2}$\n\n\n\nEquivalencia entre masa y energía: \\(E = mc^{2}\\)\n\n\n\n\nEquivalencia entre masa y energía: $$E = mc^{2}$$\n\n\nEquivalencia entre masa y energía:\n\\[E = mc^{2}\\]\n\n\n\n\nPara más detalles sobre la sintaxis de ecuaciones, se recomienda consultar:\n\nWriting mathematical expressions - GitHub Docs\nLaTeX/Mathematics"
  },
  {
    "objectID": "05-markdown.html#ejercicios",
    "href": "05-markdown.html#ejercicios",
    "title": "5  Markdown - lenguaje de marcado",
    "section": "5.7 Ejercicios",
    "text": "5.7 Ejercicios\n\nCon RStudio, cree un documento Markdown llamado README.md y escriba en este un breve curriculum académico o profesional.\n\nIncluya información como: nombre, fotografía, datos de contacto, áreas de interés, carrera, cursos aprobados, publicaciones, etc.\nPuede usar información ficticia (no incluya datos confidenciales o sensibles).\nEspecifique la fuente de las imágenes (y de cualquier otra información para la que sea necesario) y no utilice imágenes para las que no tiene autorización. Considere utilizar sitios con imágenes con licencias abiertas (ej. Wikimedia Commons, Unsplash, FreeImages).\nAsegúrese de utilizar los siguientes elementos de sintaxis Markdown:\n\nEncabezados de varios niveles.\nNegritas e itálicas.\nListas.\nEnlaces a sitios web.\nImágenes (al menos una local y una remota)."
  },
  {
    "objectID": "05-markdown.html#recursos-de-interés",
    "href": "05-markdown.html#recursos-de-interés",
    "title": "5  Markdown - lenguaje de marcado",
    "section": "5.8 Recursos de interés",
    "text": "5.8 Recursos de interés\nCarrera Arias, F. J. (2020). How to Install R on Windows, Mac OS X, and Ubuntu Tutorial. DataCamp Community. https://www.datacamp.com/community/tutorials/installing-R-windows-mac-ubuntu\nDaring Fireball: Markdown. (s. f.). Recuperado 25 de marzo de 2023, de https://daringfireball.net/projects/markdown/\nLaTeX/Mathematics—Wikibooks, open books for an open world. (s. f.). Recuperado 25 de marzo de 2023, de https://en.wikibooks.org/wiki/LaTeX/Mathematics\nMarkdown Guide. (s. f.). Recuperado 10 de abril de 2022, de https://www.markdownguide.org/\nQuarto—Markdown Basics. (s. f.). Recuperado 25 de marzo de 2023, de https://quarto.org/docs/authoring/markdown-basics.html\nWriting mathematical expressions. (s. f.). GitHub Docs. Recuperado 25 de marzo de 2023, de https://ghdocs-prod.azurewebsites.net/en/get-started/writing-on-github/working-with-advanced-formatting/writing-mathematical-expressions"
  },
  {
    "objectID": "06-git.html",
    "href": "06-git.html",
    "title": "6  Git - sistema de control de versiones",
    "section": "",
    "text": "Git es un sistema para administrar versiones de código fuente o, en general, de cualquier conjunto de archivos. Un sistema de administración de versiones permite recuperar versiones anteriores de los archivos e integrar modificaciones efectuadas por varias personas, entre otras capacidades. Git es utilizado en varios sitios que proveen servicios de alojamiento de software, incluído GitHub.\nGit puede utilizarse para sincronizar la versión local (i.e. en una computadora personal) de un conjunto de archivos, llamado proyecto o repositorio, con la versión que está alojada en un sistema remoto (ej. GitHub). Cada repositorio se almacena en un directorio (carpeta) del sistema operativo. La sincronización se realiza principalmente a través de las operaciones:\n\npush: para “subir” al repositorio remoto los cambios realizados en el repositorio local.\npull: para “bajar” al repositorio local los cambios realizados en el repositorio remoto.\n\nEl sistema Git cuenta con otras muchas operaciones, como commit, para guardar los cambios realizados."
  },
  {
    "objectID": "06-git.html#trabajo-previo",
    "href": "06-git.html#trabajo-previo",
    "title": "6  Git - sistema de control de versiones",
    "section": "6.2 Trabajo previo",
    "text": "6.2 Trabajo previo\n\n6.2.1 Instalación de software\nInstale en su computadora:\n\nGit\n\n\n\n6.2.2 Tutoriales\nAbba, I. V. (2021, noviembre 5). Git and GitHub Tutorial – Version Control for Beginners. FreeCodeCamp.Org. https://www.freecodecamp.org/news/git-and-github-for-beginners/\n\n\n6.2.3 Otros\nCree una cuenta gratuita en la plataforma de desarrollo colaborativo de software GitHub."
  },
  {
    "objectID": "06-git.html#introducción",
    "href": "06-git.html#introducción",
    "title": "6  Git - sistema de control de versiones",
    "section": "6.3 Introducción",
    "text": "6.3 Introducción\nGit es un sistema de control de versiones diseñado para “rastrear” cambios en el código fuente durante el proceso de desarrollo de software. Sin embargo, puede ser utilizado para llevar el control de los cambios en cualquier conjunto de archivos (ej. documentación, música).\nUn sistema de control de versiones proporciona, entre otras ventajas:\n\nLa capacidad de recuperar versiones anteriores de los archivos.\nLa capacidad de integrar modificaciones efectuadas por varias personas en el mismo conjunto de archivos.\nLa capacidad de mantener varias “ramas” (branches) de un producto (ej. “estable”, “evaluación”, “inestable”, como en el caso de Debian Linux, GRASS GIS y muchos otros proyectos de software libre).\nFacilidades para mantener redundancia y respaldos de los archivos (ej. Programa de respaldos de GitHub). Esta es una facilidad que implementan algunos servicios en la nube.\n\nGit fue diseñado por Linus Torvalds en 2005 durante del desarrollo del kernel del sistema operativo Linux. Se caracteriza por ser un sistema de control de versiones distribuido, lo que significa que el código fuente puede estar alojado en la estación de trabajo de cualquier miembro del equipo de desarrollo. No requiere un repositorio “central”, pero también puede trabajar de esa forma.\nEl protocolo de Git es utilizado en varios sitios que proveen servicios de alojamiento de software, entre los que están SourceForge, Bitbucket, GitLab y GitHub."
  },
  {
    "objectID": "06-git.html#funcionamiento-de-git",
    "href": "06-git.html#funcionamiento-de-git",
    "title": "6  Git - sistema de control de versiones",
    "section": "6.4 Funcionamiento de Git",
    "text": "6.4 Funcionamiento de Git\nDesde el punto de vista de un usuario de Git (ej. un programador), Git se utiliza para sincronizar la versión local (i.e. en una computadora personal) de un conjunto de archivos, llamado proyecto o repositorio, con la versión que está alojada en un sistema remoto (ej. GitHub). Cada repositorio se almacena en un directorio (carpeta) del sistema operativo. La sincronización se realiza principalmente a través de dos operaciones:\n\npush: para “subir” al repositorio remoto los cambios realizados en el repositorio local. Esta operación se realiza mediante el comando git push. Es probable que el sistema remoto le solicite al usuario algún tipo de autenticación (ej. nombre de usuario y clave).\npull: para “bajar” al repositorio local los cambios realizados en el repositorio remoto. Esta operación se realiza mediante el comando git pull.\n\nLas operaciones push y pull se ilustran en la Figura 6.1.\n\n\n\n\n\nFigura 6.1: Operaciones push y pull. Imagen de Melinda Higgins.\n\n\n\n\nAntes de un push, el usuario debe seleccionar los archivos que desea subir mediante el comando git add, el cual pasa los archivos a un “área de espera” (staging area). Luego debe usarse el comando git commit para “guardar” los cambios pendientes en el área de espera. Cada commit guarda el estado del conjunto de archivos en un momento específico (snapshot).\nLa relación entre estas operaciones de Git, se ilustra en la Figura 6.2.\n\n\n\n\n\nFigura 6.2: Operaciones de Git. Imagen de Steven Klavins.\n\n\n\n\nEn la Figura 6.3, se muestra el funcionamiento de Git mediante una comparación con el procesamiento de una compra en línea.\n\n\n\n\n\nFigura 6.3: Operaciones de Git y compras en línea. Imagen de Melinda Higgins.\n\n\n\n\nOtras operaciones de Git de uso frecuente son:\n\ngit config: para especificar opciones globales de la sesión de Git (ej. nombre del usuario, dirección de correo electrónico).\ngit init: para inicializar un repositorio git.\ngit clone: para clonar (i.e. copiar) un repositorio remoto en la computadora local.\ngit status: para revisar el estado de los archivos y, por ejemplo, saber cuales deben pasarse al área de espera.\ngit log: para revisar el historial de commits.\ngit show: para visualizar los cambios efectuados en los commits.\ngit reset: para regresar al estado correspondiente a un commit anterior."
  },
  {
    "objectID": "06-git.html#ejemplos-de-uso",
    "href": "06-git.html#ejemplos-de-uso",
    "title": "6  Git - sistema de control de versiones",
    "section": "6.5 Ejemplos de uso",
    "text": "6.5 Ejemplos de uso\n\n6.5.1 Clonación de un repositorio remoto y sincronización de los cambios efectuados localmente\nPara seguir este ejemplo:\n\nObtenga un token de GitHub en la siguiente opción de menú de su perfil de usuario: Settings - Developer settings - Personal access tokens - Tokens (classic) - Generate new token (classic). Ingrese una descripción y seleccione las operaciones de tipo “repo”. Presione Generate token. Copie el token en un lugar seguro, ya que lo necesitará para autenticarse en GitHub.\nRealice un fork a su cuenta en GitHub del repositorio localizado en la dirección https://github.com/gf0604-procesamientodatosgeograficos/2023-i-tutorial-git-repo-ejemplo. Obtendrá un repositorio llamado “https://github.com/[nombre-usuario]/2023-i-tutorial-git-repo-ejemplo”, en donde [nombre-usuario] es su nombre de usuario en GitHub.\nCon la opción File - New Project - Version Control - Git de RStudio, clone a su computadora el repositorio que acaba de bifurcar.\nCon el editor de RStudio, abra el archivo README.md, agregue una línea y guarde el archivo.\nLuego, ejecute los siguientes comandos desde la la ventana Terminal de RStudio para sincronizar el repositorio local y el repositorio remoto (las líneas que empiezan con # son comentarios).\n\n# a. Parámetros de configuración: nombre y dirección de correo del usuario.\n#    Debe cambiar [email-usuario] y [nombre-usuario] por sus propios datos, sin usar los [].\ngit config --global user.email [email-usuario]\ngit config --global user.name [nombre-usuario]\n# Para revisar los parámetros de configuración:\ngit config --global --list\n\n# b. Revisión de los archivos con modificaciones.\ngit status\n\n# c. Adición (add) de los archivos modificados al \"área de espera\".\n#    El punto (.) indica que se agregarán todos los archivos modificados.\ngit add .\n\n# d. Grabado (commit) del conjunto de archivos modificados,\n#    junto con un mensaje explicativo:\n#    Debe cambiar [comentario] por su propio comentario (ej. \"Agregar línea 2\"), sin usar los [].\ngit commit -m [comentario]\n\n# e. \"Subida\" (push) de las modificaciones al repositorio remoto.\n#    En este paso, es posible que deba utilizar su nombre de usuario/clave\n#    o su token de GitHub para autenticarse.\ngit push\n\nRevise los cambios aplicados en el repositorio remoto en GitHub.\nAgregue más líneas al archivo del repositorio local y sincronícelo con el remoto, realizando nuevamente los pasos del b al e para cada commit. Recuerde que los comentarios de cada commit deben reflejar los cambios que están siendo aplicados."
  },
  {
    "objectID": "06-git.html#ejercicios",
    "href": "06-git.html#ejercicios",
    "title": "6  Git - sistema de control de versiones",
    "section": "6.6 Ejercicios",
    "text": "6.6 Ejercicios\n\nCree un repositorio en GitHub (ej. currículum).\nClone el nuevo repositorio a su computadora.\nCopie al directorio del repositorio clonado el archivo README.md que creó en el capítulo anterior, con su currículum.\nSincronice ambos repositorios.\nPublique su curriculum como un sitio web en GitHub Pages, con la opción Settings - Pages. Elija la rama (branch) main y guarde los cambios. El sitio tomará algunos segundos para generarse.\nRealice cambios adicionales en su currículum y sincronícelos con el repositorio remoto."
  },
  {
    "objectID": "06-git.html#recursos-de-interés",
    "href": "06-git.html#recursos-de-interés",
    "title": "6  Git - sistema de control de versiones",
    "section": "6.7 Recursos de interés",
    "text": "6.7 Recursos de interés\nGit. (s. f.). Recuperado 28 de agosto de 2022, de https://git-scm.com/\nGitHub Archive Program. (s. f.). GitHub Archive Program. Recuperado 10 de abril de 2022, de https://archiveprogram.github.com/\nHiggins, M. (s. f.). Reproducible Templates for Analysis and Dissemination. Coursera. Recuperado 11 de abril de 2022, de https://www.coursera.org/learn/reproducible-templates-analysis\nKlavins, S. (2020). Version Control part 1. Medium. https://stevenklavins94.medium.com/version-control-part-1-c5f1b43127f6"
  },
  {
    "objectID": "parte-ii-r.html",
    "href": "parte-ii-r.html",
    "title": "II - El lenguaje de programación R",
    "section": "",
    "text": "8 Quarto - sistema de publicación técnica y científica\n9 Tidyverse - colección de paquetes para ciencia de datos"
  },
  {
    "objectID": "07-r.html",
    "href": "07-r.html",
    "title": "7  R - lenguaje de programación para análisis estadístico",
    "section": "",
    "text": "R es un lenguaje de programación y un entorno para graficación y análisis estadístico. Como lenguaje, es interpretado, multiplataforma, de tipado dinámico y multiparadigma. Es un proyecto de software libre que se comparte mediante una licencia GNU GPL.\nEl código de R se estructura en funciones, las cuales se distribuyen en paquetes. Cada paquete contiene un conjunto de funciones relacionadas. Algunos paquetes están incorporados en la instalación base de R y otros deben instalarse separadamente.\nR puede manejar diversos tipos de datos básicos, como números, textos y valores lógicos, entre otros. También tipos de datos compuestos, como factores y data frames. Al igual que otros lenguajes de programación, cuenta con estructuras de control como condicionales y ciclos."
  },
  {
    "objectID": "07-r.html#trabajo-previo",
    "href": "07-r.html#trabajo-previo",
    "title": "7  R - lenguaje de programación para análisis estadístico",
    "section": "7.2 Trabajo previo",
    "text": "7.2 Trabajo previo\n\n7.2.1 Lecturas\nGrolemund, G., & Wickham, H. (2014). Hands-On Programming with R: Write Your Own Functions And Simulations (capítulos 1 - 12). O’Reilly Media. https://rstudio-education.github.io/hopr/"
  },
  {
    "objectID": "07-r.html#introducción",
    "href": "07-r.html#introducción",
    "title": "7  R - lenguaje de programación para análisis estadístico",
    "section": "7.3 Introducción",
    "text": "7.3 Introducción\nR es un lenguaje de programación y un entorno enfocado en graficación y en análisis estadístico. Fue creado por Ross Ihaka y Robert Gentleman en la Universidad de Auckland, Nueva Zelanda, en 1993. Es ampliamente utilizado en diversas áreas de investigación, entre las que pueden mencionarse aprendizaje automático (machine learning), ciencia de datos (data science) y big data, con aplicaciones en campos como agricultura, biomedicina, bioinformática, finanzas, hidrología, teledetección y geografía entre muchos otros.\nAlgunas de las principales características del lenguaje de programación R son:\n\nEs interpretado: las instrucciones se traducen una por una a lenguaje máquina, a diferencia de los lenguajes compilados, que traducen de manera conjunta las instrucciones de una unidad completa (ej. un programa o una biblioteca). Los lenguajes interpretados tienden a ser más lentos que los compilados, pero también son más flexibles.\nEs multiplataforma: puede ejecutarse en los sistemas operativos más populares (ej. Microsoft Windows, macOS, Linux).\nTiene un sistema de tipos de datos dinámico: las variables pueden tomar diferentes tipos de datos (ej. textuales, numéricos) durante la ejecución del programa, a diferencia del caso de un sistema de tipos de datos estático, en el que las variables de un programa solo pueden tener un tipo de datos.\nSoporta varios paradigmas de programación: los paradigmas son estilos o enfoques teóricos de programación. R soporta los paradigmas de programación funcional, programación orientada a objetos, programación imperativa y programación procedimental.\n\nR es un proyecto de software libre que se comparte mediante una licencia GNU General Public Licence (GNU GPL). Esta característica permite que la funcionalidad original de R pueda ser ampliada mediante bibliotecas o paquetes desarrollados por la comunidad de programadores.\nLa Comprehensive R Archive Network (CRAN) es una red mundial distribuida de servidores que albergan el código y la documentación oficial de R. Las tasks views de CRAN categorizan la funcionalidad de R de acuerdo con temáticas determinadas.\nPara programar en R, puede utilizarse una interfaz de línea de comandos, editores de texto (ej. Visual Studio Code, Vim) y también ambientes de desarrollo integrados (IDE, integrated development environment) como Jupyter o RStudio."
  },
  {
    "objectID": "07-r.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "href": "07-r.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "title": "7  R - lenguaje de programación para análisis estadístico",
    "section": "7.4 El ambiente de desarrollo integrado RStudio",
    "text": "7.4 El ambiente de desarrollo integrado RStudio\nRStudio es el IDE más popular para el lenguaje R. Está disponible en una versión de escritorio (RStudio Desktop) y en una versión para servidor (RStudio Server). Esta última permite la conexión de varios usuarios a través de un navegador web. RStudio se ofrece también como un servicio en la nube, a través de RStudio Cloud.\nLa Figura 7.1 muestra la interfaz de RStudio.\n\n\n\n\n\nFigura 7.1: Interfaz del ambiente de desarrollo integrado RStudio.\n\n\n\n\nAdemás de edición de código fuente en R (y otros lenguajes), RStudio contiene capacidades para depurar código y visualizar datos en formatos tabulares, gráficos y de mapas."
  },
  {
    "objectID": "07-r.html#conjuntos-de-datos-para-pruebas",
    "href": "07-r.html#conjuntos-de-datos-para-pruebas",
    "title": "7  R - lenguaje de programación para análisis estadístico",
    "section": "7.5 Conjuntos de datos para pruebas",
    "text": "7.5 Conjuntos de datos para pruebas\nPara efectos de pruebas y ejemplos, la distribución base de R incorpora varios conjuntos de datos que pueden listarse con la función data(). Para obtener información acerca de un conjunto de datos en particular, puede utilizarse el operador ?.\n\n# Información sobre todos los conjuntos de datos incorporados en la distribución base de R\ndata()\n\n# Información sobre el cojunto de datos \"cars\"\n?cars\n\n# Información sobre el cojunto de datos \"mtcars\"\n?mtcars\n\n# Información sobre el cojunto de datos \"Iris\"\n?iris\n\nAdemás, existen muchos sitios en Internet que brindan acceso a conjuntos de datos que pueden utilizarse para pruebas. Por ejemplo:\n\nKaggle - conjuntos de datos\nBanco Mundial - indicadores\nPapers with Code - conjuntos de datos"
  },
  {
    "objectID": "07-r.html#funciones",
    "href": "07-r.html#funciones",
    "title": "7  R - lenguaje de programación para análisis estadístico",
    "section": "7.6 Funciones",
    "text": "7.6 Funciones\nR, al igual que otros lenguajes de programación, estructura su funcionalidad en unidades de código fuente llamadas funciones. Cada función realiza una tarea específica como, por ejemplo, un cálculo matemático y, por lo general, retorna un valor como salida. Todas las funciones tienen un nombre y, opcionalmente, un conjunto de argumentos que especifican los datos de entrada que procesa la función. Los argumentos se escriben entre paréntesis redondos (()) y estos siempre deben incluirse, aún en el caso de que la función no tenga ningún argumento. Si la función tiene varios argumentos, deben separarse mediante comas (,).\n\n7.6.1 Ejemplos\nLa función print() recibe como argumento un valor (ej. un texto o un número) para imprimirlo en la pantalla. En el siguiente fragmento de código en R, se utiliza print() para imprimir la hilera “Hola mundo”. Nótese el uso del símbolo # para comentarios (i.e. texto que no es código ejecutable).\n\n# Impresión de una hilera de caracteres\nprint(\"Hola mundo\")\n\n[1] \"Hola mundo\"\n\n\nLa función mean() retorna la media aritmética del argumento de entrada. En el siguiente ejemplo, se calcula la media de los números de un vector creado a su vez con la función c().\n\n# Media aritmética\nmean(c(2, 4, 5, 9))\n\n[1] 5\n\n\nLa función getwd() (get working directory) retorna la ruta del directorio de trabajo de la sesión actual de R. Este es el directorio en el cual R espera encontrar, por ejemplo, archivos de datos.\n\n# Impresión del directorio de trabajo\ngetwd()\n\n[1] \"/home/mfvargas/gf0604-procesamientodatosgeograficos/2023-i/github/2023-i\"\n\n\nLa función setwd() (set working directory) establece la ruta del directorio de trabajo de la sesión actual de R. Como argumento, recibe una hilera de texto con la ruta.\nNote las barras utilizadas para separar los subdirectorios: / (no \\)\n\n# Especificación del directorio de trabajo (la ruta debe existir)\nsetwd(\"C:/Users/mfvargas\")\n\n\n\n7.6.2 Ejercicios\n\nObtenga la ruta de su directorio de trabajo con la función getwd().\n\nSi lo desea, cambie la ruta de su directorio de trabajo con la función setwd(). Verifique el cambio usando nuevamente getwd().\n\n\n\n7.6.3 Argumentos\nLos argumentos de las funciones tienen nombres que pueden especificarse, en caso de ser necesario, al llamar la función. En algunos casos, el orden y el tipo de datos de los argumentos permiten que el interpretador de R conozca cuál es cada uno, sin necesidad de escribir sus nombres.\nEn el siguiente ejemplo, se utilizan los argumentos x, xlab y ylab de la función plot(), para especificar la fuente de datos y las etiquetas de los ejes x e y de un gráfico de dispersión.\n\n# Gráfico de dispersón del conjunto de datos \"cars\" con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\n\n\n\n\n\n\n7.6.4 Ejercicios\n\nEstudie la documentación de la función plot() y agregue al gráfico anterior:\n\nUn título.\nUn subtítulo.\n\n\n\n\n7.6.5 Ayuda\nPara obtener ayuda sobre una función desde la línea de comandos de R, puede utilizarse un signo de pregunta (?) seguido del nombre de la función o bien la función help(). Por ejemplo:\n\n# Ayuda de la función setwd()\n?setwd\nhelp(setwd)\n\nTambién puede utilizarse la función apropos(), para buscar funciones por palabras clave.\n\n# Búsqueda, por palabras clave, de funciones relacionadas con \"mean\" (media aritmética). Note las comillas (\"\").\napropos(\"mean\")\n\n [1] \".colMeans\"     \".rowMeans\"     \"colMeans\"      \"kmeans\"       \n [5] \"mean\"          \"mean.Date\"     \"mean.default\"  \"mean.difftime\"\n [9] \"mean.POSIXct\"  \"mean.POSIXlt\"  \"rowMeans\"      \"weighted.mean\"\n\n\nLa función example() presenta ejemplos sobre el uso de una función.\n\n# Ejemplos de uso de la función mean()\nexample(\"mean\")\n\n\nmean> x <- c(0:10, 50)\n\nmean> xm <- mean(x)\n\nmean> c(xm, mean(x, trim = 0.10))\n[1] 8.75 5.50\n\n\nPor otra parte, el sitio All R Documentation reúne documentación de funciones de una gran cantidad de paquetes de R.\nTambién puede obtenerse ayuda en buscadores de Internet, como Google, o en sitios de preguntas y respuestas para programadores, como Stack Overflow."
  },
  {
    "objectID": "07-r.html#paquetes",
    "href": "07-r.html#paquetes",
    "title": "7  R - lenguaje de programación para análisis estadístico",
    "section": "7.7 Paquetes",
    "text": "7.7 Paquetes\nLas funciones de R se distribuyen en paquetes. Cada paquete contiene un conjunto de funciones relacionadas. También hay paquetes que contienen datos (ej. los resultados de un censo).\nPara utilizar un paquete, primero debe cargarse (en la memoria del computador) con la función library().\n\n# Carga del paquete stats\nlibrary(stats)\n\nAlgunos paquetes están contenidos en la distribución base de R. Otros deben instalarse con la función install.packages().\nEn el siguiente ejemplo, se instala el paquete PASWR2, el cual contiene el conjunto de datos TITANIC3 con una lista de pasajeros del Titanic.\n\n# Instalación del paquete PASWR2 (note las comillas)\ninstall.packages(\"PASWR2\")\n\nSeguidamente, el paquete PASWR2 se carga con la función library().\n\n# Carga de PASWR2\nlibrary(PASWR2)\n\nEl conjunto de datos TITANIC3 puede visualizarse con la función View().\n\n# Visualización del conjunto de datos TITANIC3\nView(TITANIC3)\n\nEl siguiente gráfico de barras muestra la distribución de pasajeros por clase, mediante la función barplot(). También se utiliza la función table() para generar una tabla con las cantidades de pasajeros que viajaban en cada clase.\n\n# Cantidades de pasajeros por clase\ntable(TITANIC3$pclass)\n## \n## 1st 2nd 3rd \n## 323 277 709\n\n# Gráfico de barras por clase de pasajero\nbarplot(\n  height=table(TITANIC3$pclass),\n  main=\"Distribución de pasajeros del Titanic por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\"  \n)\n\n\n\n\nLa distribución por cada clase puede dividirse en fallecidos y sobrevivientes.\n\n# Cantidades de pasajeros fallecidos y sobrevivientes por clase\n# (0 corresponde a fallecidos y 1 a sobrevivientes)\ntable(TITANIC3$survived, TITANIC3$pclass)\n##    \n##     1st 2nd 3rd\n##   0 123 158 528\n##   1 200 119 181\n\nEl siguiente gráfico muestra en un gráfico de barras apiladas la distribución de pasajeros sobrevivientes y fallecidos en cada clase.\n\n# Gráfico de barras apiladas\nbarplot(\n  height = table(TITANIC3$survived, TITANIC3$pclass),\n  main = \"Distribución de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",\n  col = topo.colors(2)\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\nLa misma información se muestra seguidamente en un gráfico de barras agrupadas. Note el uso del argumento beside.\n\n# Gráfico de barras agrupadas\nbarplot(\n  height = table(TITANIC3$survived, TITANIC3$pclass),\n  main = \"Distribución de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",  \n  col = topo.colors(2),\n  beside = TRUE\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\n\n7.7.1 Ejercicios\n\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras apiladas.\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras agrupadas."
  },
  {
    "objectID": "07-r.html#tipos-de-datos",
    "href": "07-r.html#tipos-de-datos",
    "title": "7  R - lenguaje de programación para análisis estadístico",
    "section": "7.8 Tipos de datos",
    "text": "7.8 Tipos de datos\nR puede trabajar con varios tipos de datos básicos, entre los que están números, caracteres (i.e. textos) y lógicos. También puede trabajar con tipos compuestos, como factores y data frames.\nR proporciona acceso a los datos a través de objetos. Un objeto es una entidad que tiene asociadas propiedades (i.e. datos) y métodos (i.e. funciones) para manipular esas propiedades. Un objeto puede ser, por ejemplo, un número, una hilera de texto, un vector o una matriz. R también permite que el programador defina sus propios objetos.\nHay muchas formas de crear objetos en R. Una de las más sencillas es con los operadores de asignación. Estos son = y <- (o ->). Por ejemplo, las siguientes sentencias crean un número, un texto y un vector.\n\n# Número\nx <- 10\nx\n## [1] 10\n\n# Otro número\n20 -> y\ny\n## [1] 20\n\n# Hilera de caracteres\nnombre <- 'Manuel'\nnombre\n## [1] \"Manuel\"\n\n# Vector de hileras de caracteres\ndias <- c('Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado')\ndias\n## [1] \"Domingo\"   \"Lunes\"     \"Martes\"    \"Miércoles\" \"Jueves\"    \"Viernes\"  \n## [7] \"Sábado\"\n\nTanto x, como nombre como dias son variables. Una variable es una etiqueta que se le asigna a un objeto. Una variable debe comenzar con una letra.\nEl tipo de un objeto puede consultarse con la función typeof(). Por ejemplo:\n\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(nombre)\n## [1] \"character\"\ntypeof(dias)\n## [1] \"character\"\n\nA continuación, se describen con más detalle algunos de los tipos de datos utilizados en el lenguaje R.\n\n7.8.1 Tipos básicos\nR define seis tipos de datos básicos. En esta sección, se describen los más utilizados durante este curso.\n\n7.8.1.1 Números\nPueden ser enteros (integer) o decimales (double). Se utilizan en diversos tipos de operaciones, incluyendo las aritméticas (ej. suma, resta, multiplicación, división).\n\n# Declaración de variables numéricas\nx <- 5\ny <- 0.5\n\n# Suma\nx + y\n## [1] 5.5\n\n# Tipos de datos numéricos\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(x + y)\n## [1] \"double\"\n\nNótese que al declararse una variable numérica, ya sea que tenga o no punto decimal, R la considera por defecto de tipo double. Para que se considere de tipo integer, debe utilizarse el sufijo L o la función as.integer().\n\n# Números enteros\nx <- 10L\ny <- as.integer(15)\n\n# Multiplicación\nx * y\n## [1] 150\n\n# Tipos de datos enteros\ntypeof(x)\n## [1] \"integer\"\ntypeof(y)\n## [1] \"integer\"\ntypeof(x * y)\n## [1] \"integer\"\n\n\n\n7.8.1.2 Caracteres\nSe utilizan para representar textos. Deben estar entre comillas simples ('') o dobles (\"\").\n\n# Hileras de caracteres\nnombre <- \"María\"\napellido <- \"Pérez\"\n\n# Concatenación mediante la función paste()\npaste(nombre, apellido)\n## [1] \"María Pérez\"\n\n\n\n7.8.1.3 Lógicos\nLos objetos lógicos (también llamados booleanos) tienen dos posibles valores: verdadero (TRUE) o falso (FALSE).\n\n# Variable lógica\na <- 1 < 2\na\n## [1] TRUE\n\n# Variable lógica\nb <- 1 > 2\nb\n## [1] FALSE\n\nLas expresiones lógicas pueden combinarse con operadores como:\n\n& (Y, en inglés AND)\n| (O, en inglés OR)\n! (NO, en inglés NOT)\n\n\n# Operador lógico AND\n(1 < 2) & (3 < 4)\n## [1] TRUE\n\n# Operador lógico OR\n(2 + 2 == 5) | (20 <= 10)\n## [1] FALSE\n\n# Operador lógico NOT\n!(2 + 2 == 5)\n## [1] TRUE\n\n\n\n7.8.1.4 Vectores\nUn vector es una estructura unidimensional que combina objetos del mismo tipo.\n\n7.8.1.4.1 Definición\nLos vectores pueden definirse de varias formas como, por ejemplo, con la función c() (del inglés combine):\n\n# Definición de un vector de números\nvector_numeros <- c(1, 7, 32, 45, 57)\nvector_numeros\n## [1]  1  7 32 45 57\n\n# Definición de un vector de hileras de caracteres\nvector_nombres <- c(\"Álvaro\", \"Ana\", \"Berta\", \"Bernardo\")\nvector_nombres\n## [1] \"Álvaro\"   \"Ana\"      \"Berta\"    \"Bernardo\"\n\nLos vectores también pueden crearse con el operador :, el cual especifica una secuencia (i.e. una lista ordenada):\n\n# Definición de un vector de números con la secuencia de 1 a 10\nvector_secuencia <- 1:10\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números con la secuencia de -5 a 5\nvector_secuencia <- -5:5\nvector_secuencia\n##  [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n# Definición de un vector de números con la secuencia de -0.5 a 3.7\nvector_secuencia <- -0.5:3.7\nvector_secuencia\n## [1] -0.5  0.5  1.5  2.5  3.5\n\nLa función seq() también crea un vector con base en una secuencia y permite especificar argumentos como un valor de incremento y la longitud de la secuencia.\n\n# Definición de un vector de números en secuencia de 1 a 10\nvector_secuencia <- seq(1, 10)\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números en secuencia de 0.5 a 15.3, con incremento de 2\nvector_secuencia <- seq(from=0.5, to=15.3, by=2)\nvector_secuencia\n## [1]  0.5  2.5  4.5  6.5  8.5 10.5 12.5 14.5\n\n# Definición de un vector de números en secuencia de 1.5 a 9.4, con longitud de 4\nvector_secuencia <- seq(from=1.5, to=9.4, length.out=4)\nvector_secuencia\n## [1] 1.500000 4.133333 6.766667 9.400000\n\n\n\n7.8.1.4.2 Indexación\nLos elementos de un vector se acceden a través de sus índices (i.e. posiciones). La primera posición corresponde al índice 1, la segunda al índice 2 y así sucesivamente. Los índices se especifican entre paréntesis cuadrados ([]), ya sea para una posición específica o para un rango de posiciones. También es posible especificar los índices que se desea excluir.\n\n# Vector de nombres de países\npaises <- c(\"Argentina\", \"Francia\", \"China\", \"Australia\", \"México\")\npaises\n## [1] \"Argentina\" \"Francia\"   \"China\"     \"Australia\" \"México\"\n\n# Elemento en el índice 3\npaises[3]\n## [1] \"China\"\n\nEl operador : puede utilizarse para especificar un rango de índices:\n\n# Elementos entre los índices 2 y 4 (2, 3 y 4)\npaises[2:4]\n## [1] \"Francia\"   \"China\"     \"Australia\"\n\nCon la función c(), es posible especificar un conjunto de índices particulares:\n\n# Elementos entre los índices 1, 4 y 5\npaises[c(1, 4, 5)]\n## [1] \"Argentina\" \"Australia\" \"México\"\n\nLos números negativos pueden usarse para excluir índices:\n\n# Exclusión de los índices 3 y 4\npaises[c(-3, -4)]\n## [1] \"Argentina\" \"Francia\"   \"México\"\n\nLos valores lógicos TRUE y FALSE también pueden usarse para incluir y excluir índices de un vector:\n\n# Se incluyen los índices 1, 2 y 4; y se excluyen los índices 3 y 5\npaises[c(TRUE, TRUE, FALSE, TRUE, FALSE)]\n## [1] \"Argentina\" \"Francia\"   \"Australia\"\n\n\n\n7.8.1.4.3 Operaciones\nEn los vectores pueden aplicarse operaciones aritméticas:\n\na <- c(1, 3, 5, 7)\nb <- c(2, 4, 6, 8)\n\n# Suma de vectores\na + b\n## [1]  3  7 11 15\n\n# Multiplicación de vectores\na * b\n## [1]  2 12 30 56\n\nY también pueden realizarse operaciones relacionales:\n\n# Comparación con el operador <\na < b\n## [1] TRUE TRUE TRUE TRUE\n\n\n\n\n7.8.1.5 Matrices\nUna matriz es una estructura bidimensional de filas y columnas.\n\n7.8.1.5.1 Definición\nLas matrices se definen mediante la función matrix().\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las columnas\nm <- matrix(1:9, nrow=3, ncol=3)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    4    7\n## [2,]    2    5    8\n## [3,]    3    6    9\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las filas\nm <- matrix(1:9, nrow=3, ncol=3, byrow=TRUE)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    4    5    6\n## [3,]    7    8    9\n\n# Definición de una matriz de 3 x 2 con nombres para las filas y las columnas\ndatos <- c(18, 500, 25, 1000, 30, 2000)\nfilas <- c(\"Ana\", \"Mario\", \"Laura\")\ncolumnas <- c(\"Edad\", \"Salario\")\n\nm <- matrix(datos, nrow=3, ncol=2, byrow=TRUE, dimnames=list(filas, columnas))\nm\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n## Laura   30    2000\n\nLa función list() se utiliza, en este caso, para combinar vectores. En general, se usa para combinar datos de cualquier tipo.\n\n\n7.8.1.5.2 Indexación\nLa indexación de matrices es similar a la de vectores, pero deben especificarse índices tanto para filas como para columnas.\n\n# Elemento en la posición [2,2] (segunda fila, segunda columna)\nm[2, 2]\n## [1] 1000\n\n# Elementos de la primera fila\nm[1,]\n##    Edad Salario \n##      18     500\n\n# Elementos de la segunda columna\nm[, 2]\n##   Ana Mario Laura \n##   500  1000  2000\n\n# Elementos de las filas 1 y 2\nm[1:2, ]\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n\n# Elementos de la fila \"Mario\"\nm[\"Mario\", ]\n##    Edad Salario \n##      25    1000\n\n# Elementos de la columna \"Salario\"\nm[, \"Salario\"]\n##   Ana Mario Laura \n##   500  1000  2000\n\n\n\n7.8.1.5.3 Operaciones\nDe manera similar a los vectores, en las matrices pueden realizarse operaciones aritméticas y relacionales.\n\na <- matrix(1:4, nrow=2, ncol=2)\na\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n\nb <- matrix(5:8, nrow=2, ncol=2)\nb\n##      [,1] [,2]\n## [1,]    5    7\n## [2,]    6    8\n\n# Suma de matrices\na + b\n##      [,1] [,2]\n## [1,]    6   10\n## [2,]    8   12\n\n# Multiplicación de matrices\na * b\n##      [,1] [,2]\n## [1,]    5   21\n## [2,]   12   32\n\n# Comparación de matrices con el operador >\na > b\n##       [,1]  [,2]\n## [1,] FALSE FALSE\n## [2,] FALSE FALSE\n\n\n\n\n\n7.8.2 Tipos compuestos\n\n7.8.2.1 Factores\nLos factores se utilizan para representar datos categóricos. Un factor corresponde a un conjunto de categorías correspondientes a un concepto (ej. [“Sí”, “No”], [“Casado”, “Soltero”], [“Alto”, “Medio”, “Bajo”]).\nInternamente, los factores se representan en R como números enteros con etiquetas asociadas. A pesar de que los factores parecen (y pueden funcionar como) hileras de caracteres, en realidad son números y debe tenerse cuidado de no manejarlos como caracteres.\nLos elementos de un factor se denominan niveles (levels) y, por defecto, se almacenan en orden alfabético.\n\n7.8.2.1.1 Definición\nUn factor se crea con la función factor().\n\n# Factor de valores de sexo\nsexo <- factor(c(\"Masculino\", \"Femenino\", \"Femenino\", \"Masculino\"))\n\n\n\n7.8.2.1.2 Operaciones\nR proporciona una gran variedad de funciones para manejar factores. Seguidamente, se ejemplifican algunas de estas.\n\n# Etiquetas de los niveles\nlevels(sexo)\n## [1] \"Femenino\"  \"Masculino\"\n\n# Cantidad de niveles\nnlevels(sexo)\n## [1] 2\n\n# Conteo de elementos de cada uno de los niveles del factor\ntable(sexo)\n## sexo\n##  Femenino Masculino \n##         2         2\n\n\n\n\n7.8.2.2 Data Frames\nUn data frame es una estructura bidimensional similar a lo que comúnmente se conoce como una tabla. Sus filas corresponden a las observaciones de un conjunto de datos y sus columnas a las variables. Internamente, se componen de varios vectores, factores y/o matrices de la misma longitud. La definición de un data frame puede incluir nombres para cada observación y para cada variable. Los data frames implementan un conjunto de funciones similares a las de una hoja electrónica o una tabla de una base de datos relacional. Son fundamentales para el manejo de datos en R.\n\n7.8.2.2.1 Definición\nLa función data.frame() crea un data frame a partir de vectores que serán las columnas del data frame.\n\n# Vector de nombres de países\npaises <-\n  c(\"Panamá\",\n    \"Costa Rica\",\n    \"Nicaragua\",\n    \"El Salvador\",\n    \"Honduras\",\n    \"Guatemala\",\n    \"Belice\")\n\n# Vector de cantidades de habitantes de cada país (en millones)\npoblaciones <- c(4.1, 5.0, 6.2, 6.4, 9.2, 16.9, 0.3)\n\n# Creación de un data frame a partir de los dos vectores\npoblaciones_paises <- \n  data.frame(\n    pais = paises, \n    poblacion = poblaciones\n  )\n\n# Impresión del data frame\npoblaciones_paises\n##          pais poblacion\n## 1      Panamá       4.1\n## 2  Costa Rica       5.0\n## 3   Nicaragua       6.2\n## 4 El Salvador       6.4\n## 5    Honduras       9.2\n## 6   Guatemala      16.9\n## 7      Belice       0.3\n\n\n\n7.8.2.2.2 Indexación\nLos datos de un data frame pueden accederse principalmente de dos formas. La primera es mediante la misma sintaxis [fila, columna] que se utiliza en las matrices.\n\n# Fila 1\npoblaciones_paises[1, ]\n##     pais poblacion\n## 1 Panamá       4.1\n\n# Filas 1, 5 y 7\npoblaciones_paises[c(1, 5, 7), ]\n##       pais poblacion\n## 1   Panamá       4.1\n## 5 Honduras       9.2\n## 7   Belice       0.3\n\n# Columna 2\npoblaciones_paises[, 2]\n## [1]  4.1  5.0  6.2  6.4  9.2 16.9  0.3\n\n# Fila 1, columna 2\npoblaciones_paises[1, 2]\n## [1] 4.1\n\n# Filas 1:4, columna 2\npoblaciones_paises[1:4, 2]\n## [1] 4.1 5.0 6.2 6.4\n\nAdemás, mediante el operador $, es posible acceder a las columnas (i.e. variables) del data frame.\n\n# Columna de nombres de países\npoblaciones_paises$pais\n## [1] \"Panamá\"      \"Costa Rica\"  \"Nicaragua\"   \"El Salvador\" \"Honduras\"   \n## [6] \"Guatemala\"   \"Belice\"\n\n# Modificación de los valores de toda una columna\npoblaciones_paises$poblacion = poblaciones_paises$poblacion*2\npoblaciones_paises\n##          pais poblacion\n## 1      Panamá       8.2\n## 2  Costa Rica      10.0\n## 3   Nicaragua      12.4\n## 4 El Salvador      12.8\n## 5    Honduras      18.4\n## 6   Guatemala      33.8\n## 7      Belice       0.6\n\n\n\n7.8.2.2.3 Operaciones\nR proporciona una gran variedad de funciones para manejar data frames. Las siguientes son algunas de las más utilizadas.\nLa función read.table() lee los datos contenidos en un archivo de texto y los retorna en un data frame. read.csv() es una función derivada, con valores por defecto orientados a los archivos de valores separados por comas (CSV, Comma Separated Values). Como argumento principal, read.csv() recibe la ruta del archivo CSV, el cual puede encontrarse en un disco local, en la Web o en otra ubicación.\n\n# Lectura de archivo CSV ubicado en la Web\ncovid <-\n  read.csv(\n    \"https://raw.githubusercontent.com/pf0953-programacionr/2022-ii/main/datos/cepredenac/covid/covid-20210422.csv\"\n  )\n\n# Despliegue de los datos del data frame\ncovid\n##          pais fallecidos recuperados activos positivos\n## 1      Panamá       6198      351949    3845    361992\n## 2  Costa Rica       3125      199779   32370    235274\n## 3   Guatemala       7345      194075   16725    218145\n## 4    Honduras       4981       77020  121358    203359\n## 5 El Salvador       2089       64208    1864     68161\n## 6      Belice        318       12164     114     12596\n## 7   Nicaragua        181        5212      57      5450\n\nLa función str() despliega la estructura de un data frame u otro objeto R.\n\n# Estructura del data frame\nstr(poblaciones_paises)\n\n'data.frame':   7 obs. of  2 variables:\n $ pais     : chr  \"Panamá\" \"Costa Rica\" \"Nicaragua\" \"El Salvador\" ...\n $ poblacion: num  8.2 10 12.4 12.8 18.4 33.8 0.6\n\n\nLa función summary() proporciona un resumen de los contenidos de un data frame:\n\n# Resumen de los contenidos del data frame\nsummary(poblaciones_paises)\n\n     pais             poblacion    \n Length:7           Min.   : 0.60  \n Class :character   1st Qu.: 9.10  \n Mode  :character   Median :12.40  \n                    Mean   :13.74  \n                    3rd Qu.:15.60  \n                    Max.   :33.80  \n\n\nLa función View() invoca un visor de datos que permite visualizar un objeto R en un formato de tabla en una hoja de cálculo. Ejecute en su computadora la siguiente línea de código para apreciar el funcionamiento de View().\n\n# Vista de los casos de COVID-19\nView(covid, \"Casos de COVID-19 en Centramérica\")\n\n\n7.8.2.2.3.1 Ejercicios\n\nDescargue el archivo de datos de covid de Centroamérica (https://raw.githubusercontent.com/pf0953-programacionr/2022-ii/main/datos/cepredenac/covid/covid-20210422.csv) en su computadora y cárguelo en otro data frame mediante read.csv(), accediendo a la dirección en su disco (ej. C:/Usuarios/…).\n\n\n\n\n\n\n7.8.3 Otros\n\n7.8.3.1 Fechas\nLas fechas se manejan en R mediante un tipo especial que permite realizar operaciones como diferencias, agrupamientos y otras. Internamente, una fecha en R se almacena como un número que representa la cantidad de días transcurridos desde el 1 de enero de 1970 (1970-01-01).\n\n7.8.3.1.1 Operaciones\nLa función Sys.Date() retorna la fecha actual.\n\n# Fecha actual\nfecha_actual <- Sys.Date()\nfecha_actual\n## [1] \"2023-04-28\"\n\n# Tipo de datos\ntypeof(fecha_actual)\n## [1] \"double\"\n\n# Clase\nclass(fecha_actual)\n## [1] \"Date\"\n\nLa función as.Date() convierte datos entre los tipos fecha y carácter, de acuerdo con un formato. El formato que se usa por defecto (y el recomendado) es el que corresponde a la norma ISO 8601 (ej. 2023-12-03), pero pueden emplearse otros también.\n\n# Conversión de fecha en formato año-mes-día\nfecha_caracter_01 <- \"2020-01-01\"\nfecha_01 <- as.Date(fecha_caracter_01, format=\"%Y-%m-%d\")\nfecha_01\n\n[1] \"2020-01-01\"\n\n# Conversión de fecha en formato día/mes/año\nfecha_caracter_02 <- \"31/01/2020\"\nfecha_02 <- as.Date(fecha_caracter_02, format=\"%d/%m/%Y\")\nfecha_02\n\n[1] \"2020-01-31\"\n\n# Diferencia entre fechas\nfecha_02 - fecha_01\n\nTime difference of 30 days\n\n\nHay una lista de formatos de fechas en Date Formats in R - R-bloggers."
  },
  {
    "objectID": "07-r.html#definición-de-funciones",
    "href": "07-r.html#definición-de-funciones",
    "title": "7  R - lenguaje de programación para análisis estadístico",
    "section": "7.9 Definición de funciones",
    "text": "7.9 Definición de funciones\nAdemás de todas las funciones disponibles en la distribución base de R y en sus diferentes paquetes, R permite que los programadores definan sus propias funciones.\nToda función tiene tres partes esenciales:\n\nUn nombre.\nUn conjunto de argumentos.\nUn conjunto de líneas de código, también llamado el cuerpo de la función.\n\nPara programar una función, debe definirse cada una de esas partes por medio de la palabra reservada function function().\nPor ejemplo, la siguiente función calcula la nota final de un curso con base en los argumentos correspondientes a los promedios de exámenes, proyectos y tareas.\n\n# Función que calcula la nota final de un curso\nnota_final <- function(promedio_examenes,\n                       promedio_proyectos,\n                       promedio_tareas) {\n  factor_examenes <- promedio_examenes * 0.5\n  factor_proyectos <- promedio_proyectos * 0.4\n  factor_tareas <- promedio_tareas * 0.1\n  \n  return(factor_examenes + factor_proyectos + factor_tareas)\n}\n\nLa función return() es la que define el valor de retorno de la función. Si no se incluye, la función retorna la última expresión evaluada.\nAhora que está definida, la función nota_final() puede ser “llamada”, con diferentes argumentos:\n\n# Si ni se incluyen los nombres de los argumentos, \n# la función asume que se ingresan en el mismo orden en el que fueron definidos\nnota_final(100, 50, 0)\n## [1] 70\n\n# El uso de los nombres de argumentos \n# permite modificar su orden\nnota_final(promedio_examenes =  100, promedio_tareas =  0, promedio_proyectos = 50)\n## [1] 70\n\nSi se desea darle al usuario la opción de omitir algunos argumentos, se les puede asignar un valor por defecto.\nSeguidamente, la función nota_final() se redefine asignando valores por defecto a algunos de los argumentos:\n\n# Redefinición de la función nota final,\n# con valores por defecto para los argumentos\nnota_final <- function(promedio_examenes,\n                       promedio_proyectos = 0,\n                       promedio_tareas = 0) {\n  factor_examenes <- promedio_examenes * 0.5\n  factor_proyectos <- promedio_proyectos * 0.4\n  factor_tareas <- promedio_tareas * 0.1\n  \n  # Al no llamarse a la función return(), se retorna la última expresión:\n  factor_examenes + factor_proyectos + factor_tareas\n}\n\n# Se utiliza el valor por defecto (0) para el argumento promedio_tareas\nnota_final(promedio_examenes = 100, promedio_proyectos = 50)\n## [1] 70\n\n# Se llama la función usando la posición del primer argumento y el nombre del segundo\nnota_final(100, promedio_proyectos = 50)\n## [1] 70\n\n\n7.9.1 Ejercicios\n\nDefina una función con nombre celsius_a_fahrenheit() que reciba como argumento una cantidad en grados Celsius y retorne el equivalente en grados Fahrenheit.\n\nDefina una función con nombre fahrenheit_a_celsius() que reciba como argumento una cantidad en grados Fahrenheit y retorne el equivalente en grados Celsius.\n\nDefina una función con nombre imc() para calcular el índice de masa corporal (IMC) de una persona con base en su peso (en kilogramos) y su estatura (en metros)."
  },
  {
    "objectID": "07-r.html#condicionales",
    "href": "07-r.html#condicionales",
    "title": "7  R - lenguaje de programación para análisis estadístico",
    "section": "7.10 Condicionales",
    "text": "7.10 Condicionales\nLas sentencias condicionales evalúan una expresión lógica (i.e. condición) y ejecutan, o no, un bloque de intrucciones dependiendo de si la expresión es verdadera (TRUE) o falsa (FALSE). Permiten que los programas “tomen decisiones” y varíen su curso de acción.\nLos condicionales en R se implementa mediante la sentencia if y sus cláusulas else y else if.\n\n7.10.1 La sentencia if\nLa sentencia if evalúa una condición (i.e. una expresión lógica) y ejecuta un bloque de instrucciones, si es verdadera. El bloque se delimita con los caracteres de “llaves”: {}.\n\n# Sintaxis de la sentencia if\nif (condicion) {\n  # bloque de instrucciones a ejecutar si la condicion es verdadera\n}\n\nPor ejemplo:\n\n# Edad de una persona\nedad <- 25\n\n# Se utiliza la sentencia if para determinar \n# si la persona es adulta\nif (edad >= 18) {\n  print(\"Adulto\")\n}\n## [1] \"Adulto\"\n\nYa sea que se ejecute o no el bloque del if, el programa continúa con las instrucciones que siguen al bloque, si las hay.\n\n\n7.10.2 La cláusula else\nUna sentencia if puede ir seguida de una cláusula else, la cual define un bloque que se ejecuta si la condición es falsa. Por ejemplo:\n\nedad <- 15\n\nif (edad >= 18) {\n  print(\"Adulto\")\n} else {\n  print(\"Menor\")\n}\n\n[1] \"Menor\"\n\n\n\n\n7.10.3 La cláusula else if\nUna sentencia if también puede ir seguida de una o varias cláusulas else if, las cuales evalúan condiciones adicionales.\n\nedad <- 70\n\nif (edad < 18) {\n  print(\"Menor\")\n} else if (edad < 65) {\n  print(\"Adulto\")\n} else {\n  print(\"Adulto mayor\")\n}\n\n[1] \"Adulto mayor\"\n\n\nLas cláusulas else if deben escribirse antes de la cláusula else, la cual es siempre la última, si es que está presente. Tanto las cláusulas else if como la cláusula else son opcionales.\n\n\n7.10.4 Ejercicios\n\nDefina una función con nombre interpretacion_imc() que reciba como argumento un número correspondiente al índice de masa corporal (IMC) de una persona. Debe retornar una hilera de caracteres correspondiente a la interpretación del IMC (“Bajo peso”, “Normal”, “Sobrepeso”, “Obesidad”), de acuerdo con la tabla disponible en Índice de masa corporal - Wikipedia."
  },
  {
    "objectID": "07-r.html#ciclos",
    "href": "07-r.html#ciclos",
    "title": "7  R - lenguaje de programación para análisis estadístico",
    "section": "7.11 Ciclos",
    "text": "7.11 Ciclos\nLos ciclos permiten ejecutar tareas de manera repetitiva en un programa. Algunos ciclos se ejecutan una cantidad definida de veces, mientras que otros lo hacen mientras se cumple una condición lógica. Pueden usarse en combinación con sentencias que terminan anticipadamente el ciclo o que omiten algunas de sus iteraciones.\nLos ciclos en R se implementan mediante las sentencias for, while y repeat, en combinación con las sentencias break y next.\nR provee varias funciones que implementan ciclos de manera implícita, tales como apply(), tapply() y lapply(). Adicionalmente, hay muchas operaciones (ej. las aritméticas) que están “vectorizadas”, por lo que no es necesario utilizarlas en ciclos. El uso de código vectorizado es muy recomendado en R, por ser muy eficiente.\n\n7.11.1 La sentencia for\nLa sentencia for repite las instrucciones contenidas en un bloque para cada uno de los elementos de un vector o lista. En cada iteración (i.e. cada “vuelta” del ciclo), el valor del elemento que está siendo procesado se almacena en una variable.\n\n# Sintaxis de la sentencia for\nfor (variable in vector) {\n  # bloque de instrucciones\n}\n\nPor ejemplo, el siguiente bloque de código utiliza un ciclo de tipo for para recorrer un vector de nombres e imprimir un saludo para cada uno.\n\n# Vector con nombres de personas\nvector_nombres <- c(\"Andrés\", \"Beatriz\", \"Carlos\", \"Marta\", \"Pedro\", \"Sara\")\n\n# Recorrido del vector\nfor (nombre in vector_nombres) {\n  cat(\"Hola\", nombre, \"\\n\")\n}\n## Hola Andrés \n## Hola Beatriz \n## Hola Carlos \n## Hola Marta \n## Hola Pedro \n## Hola Sara\n\nEn el siguiente ejemplo, se utiliza otro ciclo for para recorrer un vector de números y sumar sus elementos.\n\n# Vector de números\nvector_numeros <- c(29.6, -36.81, 31.85, 25.71, 90.2, 0.4)\n\n# Variable para la suma de los números\nsuma <- 0\n\n# Recorrido del vector\nfor (x in vector_numeros) {\n  suma <- suma + x\n}\n\n# Impresión de la suma\ncat(\"Suma:\", suma)\n## Suma: 140.95\n\nSeguidamente, se utiliza dos for “anidados” para sumar los elementos de cada una de las columnas de una matriz.\n\n# Matriz de números\nmatriz_numeros <- matrix(1:12, nrow=3, ncol=4)\nmatriz_numeros\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    4    7   10\n## [2,]    2    5    8   11\n## [3,]    3    6    9   12\n\n# Ciclo externo para recorrer las columnas de la matriz\nfor (j in 1:ncol(matriz_numeros)) {\n  suma_columna <- 0\n  # Ciclo interno para recorrer las elementos de cada columna\n  for (i in 1:nrow(matriz_numeros)) {\n    suma_columna <- suma_columna + matriz_numeros[i, j]\n  }\n  print(suma_columna)\n}\n## [1] 6\n## [1] 15\n## [1] 24\n## [1] 33\n\n\n7.11.1.1 Ejercicios\nUtilice un ciclo for para recorrer el vector vector_numeros y calcular el promedio de sus elementos.\nUtilice dos ciclos for anidados para recorrer la matriz vector_numeros y calcular el promedio de cada una de sus columnas.\n\n\n\n7.11.2 La sentencia while\nLa sentencia while evalúa una condición (i.e. una expresión lógica) en cada iteración de un ciclo y ejecuta las intrucciones del bloque mientras la condición sea verdadera. Generalmente, en algún momento la condición se vuelve falsa y así finaliza el ciclo.\n\n# Sintaxis de la sentencia while\nwhile (condicion) {\n  # bloque de instrucciones \n}\n\nEn el siguiente ejemplo, se utiliza un ciclo while para preguntarle al usuario cuál es la respuesta definitiva al sentido de la vida, el universo y todo lo demás y se continúa haciendo la pregunta hasta que responda correctamente:\n\n# Función para leer una respuesta desde la pantalla\nleer_respuesta <- function() {\n  readline(prompt=\"¿Cual es la respuesta definitiva al sentido de la vida, el universo y todo lo demás? \")\n}\n\n# Si la respuesta es incorrecta, se repite la pregunta hasta que el usuario conteste correctamente\nwhile (leer_respuesta() != \"42\") {   \n  print(\"¡Su respuesta es incorrecta!\")\n}\n\n\n7.11.2.1 Ejercicios\nUtilice un ciclo while para implementar el cálculo del promedio de los elementos de un vector. Sugerencia: utilice la función length() para obtener la longitud del vector y así saber cuando terminar de recorrerlo.\n\n\n\n7.11.3 La sentencia repeat\nLa sentencia repeat implementa un ciclo que se repite indefinidamente. Puede interrumpirse con una sentencia break.\n\n# Sintaxis de la sentencia repeat\nrepeat {\n  # bloque de instrucciones \n}\n\nLos ciclos repeat tienen una estructura más sencilla que los while. Algo que los diferencia es que los bloques de los ciclos repeat se ejecutan al menos una vez.\nEn el siguiente ejemplo, se utiliza un ciclo repeat para implementar la pregunta y lectura de la respuesta que anteriormente se implementó con un ciclo while.\n\n# Función para leer una respuesta desde la pantalla\nleer_respuesta <- function() {\n  readline(prompt=\"¿Cual es la respuesta definitiva al sentido de la vida, el universo y todo lo demás? \")\n}\n\n# Ciclo para imprimir la pregunta y leer la respuesta hasta que esta sea correcta\nrepeat {\n  respuesta <- leer_respuesta()\n  if (respuesta != \"42\") {\n    # Respuesta incorrecta\n    print(\"¡Su respuesta es incorrecta!\")\n  } else {\n    # Respuesta correcta. Se interrumpe el ciclo.\n    break\n  }\n}\n\n\n\n7.11.4 Las sentencias break y next\nLa sentencia break interrumpe un ciclo. La ejecución del programa continúa con la instrucción siguiente al bloque del ciclo.\nEn el siguiente ciclo for, se suman uno a uno los números de un vector, pero se usa un break para interrumpir el ciclo cuando el acumulado es mayor que 100.\n\nvector_numeros <- c(17, 23, 37, 41, 52, 64, 75)\n\nacumulado <- 0\n\nfor (x in vector_numeros) {\n  acumulado <- acumulado + x\n  cat(\"Acumulado:\", acumulado, \"\\n\")\n  if (acumulado >= 100) {\n    cat(\"Se superó el límite de 100 en el acumulado\")\n    break\n  }\n}\n## Acumulado: 17 \n## Acumulado: 40 \n## Acumulado: 77 \n## Acumulado: 118 \n## Se superó el límite de 100 en el acumulado\n\nPor su parte, la sentencia next retorna el control al principio del bloque. Las instrucciones que hay después del next no se ejecutan. La siguiente iteración del ciclo (si la hay), se inicia entonces.\nEl siguiente ciclo recorre un vector de números. Se utiliza la sentencia next para “saltar” los números impares y sumar solo los pares.\n\nvector_numeros <- c(17, 23, 37, 41, 52, 64, 75)\n\nsuma_pares <- 0\n\nfor (x in vector_numeros) {\n  if (x %% 2 == 0) {\n    # Número par: se suma\n    suma_pares <- suma_pares + x\n  } else {\n    # Número impar: se \"salta\" al siguiente número\n    next\n  }\n}\n\ncat(\"Suma de los números pares:\", suma_pares)\n## Suma de los números pares: 116\n\n\n\n7.11.5 La familia de funciones apply()\nEsta es una familia de funciones que manipulan subconjuntos de datos obtenidos a partir de matrices, listas y data frames, los cuales son recorridos de una forma repetitiva. Pueden funcionar como una alternativa a los ciclos y aplicar funciones en los subconjuntos de datos como, por ejemplo, funciones estadísticas en las columnas de una matriz o de un data frame. Su uso es muy recomendado por su eficiencia, flexibilidad y simplicidad.\nEntre estas funciones, pueden mencionarse apply(), lapply(), sapply(), vapply(), mapply(), rapply() y tapply().\n\n7.11.5.1 La función apply()\nLa función apply() toma como entrada un arreglo o una matriz y aplica alguna función sobre sus filas o columnas.\nLa sintaxis de la función es:\n\n# Sintaxis de la función apply()\napply(X, MARGIN, FUN, ...)\n\nEn donde:\n- X: es un arreglo o matriz.\n- MARGIN: MARGIN = 1 significa que la función actúa en las filas, MARGIN = 2 significa que la función actúa en las columnas y MARGIN = c(1, 2) significa que la función actúa en las filas y en las columnas.\n- FUN: es la función que se aplicará a cada uno de los elementos de X.\nEn el siguiente ejemplo, se utiliza la función apply() para sumar los elementos de las columnas de una matriz.\n\nm <- matrix(1:12, nrow=3, ncol=4)\nm\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n# Suma de las columnas\napply(m, 2, sum)\n\n[1]  6 15 24 33\n\n\n\n7.11.5.1.1 Ejercicios\nUtilice la función apply() para obtener el promedio de los elementos de cada columna de la matriz del ejemplo anterior.\n\n\n\n7.11.5.2 La función lapply()\nLa función lapply() toma como entrada un vector o lista y retorna una lista de la misma longitud en la que cada uno de sus elementos es el resultado de aplicar una función al vector o lista de entrada.\nLa sintaxis de la función es:\n\n# Sintaxis de la función lapply()\nlapply(X, FUN, ...)\n\nEn donde:\n- X: es un vector o lista.\n- FUN: es la función que se aplicará a cada elemento de X. Algunas funciones predefinidas que pueden utilizarse incluyen mean(), median(), sum(), min() y max(). También pueden usarse funciones definidas por el usuario.\nEn los siguientes ejemplos, se utiliza lapply() para aplicar diferentes funciones a un vector de nombres de personas.\n\nnombres <- c(\"Andrés\", \"Beatriz\", \"Carlos\", \"Marta\", \"Pedro\", \"Sara\")\n\n# Los nombres de la lista se transforman a minúscula\nnombres_en_minuscula <- lapply(nombres, tolower)\nnombres_en_minuscula\n\n[[1]]\n[1] \"andrés\"\n\n[[2]]\n[1] \"beatriz\"\n\n[[3]]\n[1] \"carlos\"\n\n[[4]]\n[1] \"marta\"\n\n[[5]]\n[1] \"pedro\"\n\n[[6]]\n[1] \"sara\"\n\n# Se genera un saludo para cada nombre\nnombres_con_saludo <- lapply(nombres, function(arg1, arg2) paste(arg1, arg2), arg1=\"Hola\")\nnombres_con_saludo\n\n[[1]]\n[1] \"Hola Andrés\"\n\n[[2]]\n[1] \"Hola Beatriz\"\n\n[[3]]\n[1] \"Hola Carlos\"\n\n[[4]]\n[1] \"Hola Marta\"\n\n[[5]]\n[1] \"Hola Pedro\"\n\n[[6]]\n[1] \"Hola Sara\"\n\n\n\n\n7.11.5.3 La función tapply()\nLa función tapply() aplica una función a cada nivel de un factor.\nLa sintaxis de la función es:\n\n# Sintaxis de la función tapply()\ntapply(X, INDEX, FUN)\n\nEn donde:\n- X: es un objeto, tipicamente un vector.\n- INDEX: es una lista que contiene un factor.\n- FUN: es la función que se aplicará a cada elemento de X.\nEn el siguiente ejemplo, se utiliza tapply() para calcular la mediana del ancho del sépalo para cada especie del conjunto de datos iris.\n\ndata(iris)\ntapply(iris$Sepal.Width, iris$Species, median)\n\n    setosa versicolor  virginica \n       3.4        2.8        3.0 \n\n\n\n7.11.5.3.1 Ejercicios\nUtilice la función tapply() para obtener el promedio de las longitudes de los pétalos para cada especie del conjunto de datos iris.\n\n\n\n\n7.11.6 Vectorización\nEn R, muchas operaciones y funciones pueden ser vectorizadas, lo que significa que pueden aplicarse a los elementos de un vector sin necesidad de iterar uno por uno en estos.\nPor ejemplo, considérese el siguiente fragmento de código no vectorizado, que utiliza un ciclo para convertir los números de un vector a sus valores absolutos:\n\nvector_numeros <- c(23, -17, 34, 0, -12, 55)\n\nfor (i in 1:length(vector_numeros)) {\n  if (vector_numeros[i] < 0) {\n    vector_numeros[i] <- -vector_numeros[i]\n  }\n}\n\nvector_numeros\n## [1] 23 17 34  0 12 55\n\nEl siguiente fragmento de código realiza la misma tarea, pero de forma vectorizada:\n\nvector_numeros <- c(23, -17, 34, 0, -12, 55)\n\n# Se usa una expresión lógica para seleccionar los elementos del vector < 0\nnegativos <- vector_numeros < 0\nnegativos\n## [1] FALSE  TRUE FALSE FALSE  TRUE FALSE\n\n# Se cambian los elementos seleccionados en el paso anterior sin utilizar el for\nvector_numeros[negativos] <- vector_numeros[negativos] * -1\n\nvector_numeros\n## [1] 23 17 34  0 12 55\n\n\n7.11.6.1 Ejercicios\nUtilice código vectorizado para implementar una función que reciba como argumento un vector de números y retorne el mismo vector con los elementos impares (solo los impares) elevados al cuadrado."
  },
  {
    "objectID": "07-r.html#recursos-de-interés",
    "href": "07-r.html#recursos-de-interés",
    "title": "7  R - lenguaje de programación para análisis estadístico",
    "section": "7.12 Recursos de interés",
    "text": "7.12 Recursos de interés\nFind Open Datasets and Machine Learning Projects | Kaggle. (s. f.). Recuperado 24 de abril de 2022, de https://www.kaggle.com/datasets\nIndicators | Data. (s.f.). Recuperado 11 de septiembre de 2022, de https://data.worldbank.org/indicator\nNewest «r» Questions. (s. f.). Stack Overflow. Recuperado 24 de abril de 2022, de https://stackoverflow.com/questions/tagged/r\nPapers with Code—Machine Learning Datasets. (s.f.). Recuperado 11 de septiembre de 2022, de https://paperswithcode.com/datasets\nR Language Definition. (s. f.). Recuperado 24 de abril de 2022, de https://cran.r-project.org/doc/manuals/r-release/R-lang.html\nR Package Documentation. (s.f.). Recuperado 11 de septiembre de 2022, de https://rdrr.io/"
  },
  {
    "objectID": "08-quarto.html",
    "href": "08-quarto.html",
    "title": "8  Quarto - sistema de publicación técnica y científica",
    "section": "",
    "text": "Quarto es un sistema de publicación de documentos técnicos y científicos, basado en código abierto. Estos documentos combinan código en R, y sus salidas (ej. tablas, gráficos, mapas), con la sintaxis de Markdown."
  },
  {
    "objectID": "08-quarto.html#trabajo-previo",
    "href": "08-quarto.html#trabajo-previo",
    "title": "8  Quarto - sistema de publicación técnica y científica",
    "section": "8.2 Trabajo previo",
    "text": "8.2 Trabajo previo\n\n8.2.1 Lecturas\nQuarto - Tutorial: Hello, Quarto. (s.f.). Recuperado 22 de agosto de 2022, de https://quarto.org/docs/get-started/hello/rstudio.html"
  },
  {
    "objectID": "08-quarto.html#introducción",
    "href": "08-quarto.html#introducción",
    "title": "8  Quarto - sistema de publicación técnica y científica",
    "section": "8.3 Introducción",
    "text": "8.3 Introducción\nQuarto es un sistema de publicación de documentos técnicos y científicos, basado en código abierto. Entre sus principales capacidades están:\n\nCrear contenido dinámico con los lenguajes R, Python, Julia y Observable.\nCrear documentos Markdown de texto plano o cuadernos de notas de Jupyter.\nPublicar artículos académicos, reportes, presentaciones, sitios web, blogs y libros en HTML, PDF, MS Word, ePub y otros formatos.\nCrear contenido científico, incluyendo ecuaciones, citas bibliográficas, referencias cruzadas, figuras y otros elementos.\n\nQuarto es la siguiente generación de R Markdown, un formato que permite insertar código en R, y sus salidas, en documentos escritos en Markdown. R Markdown fue introducido por Yihui Xie en 2012, junto con el paquete knitr, cuyo propósito es facilitar la investigación reproducible en R a través de la programación literaria (literate programming), un paradigma de programación propuesto por Donald Knuth en 1984.\nLos programas “literarios” (o “letrados”) están escritos como una exposición lógica en un lenguaje humano similar a la explicación de las fórmulas y ecuaciones empleadas para representar y resolver un problema en un texto de física o de matemáticas. En estos programas, se describe el análisis del problema, su solución y su implementación, intercalando código fuente entre los párrafos (y otros contenidos como imágenes, tablas, gráficos estadísticos y mapas), de forma similar a como en los textos de matemáticas se intercalan las fórmulas y las ecuaciones. La programación literaria puede mejorar enormemente un programa, ya que permite documentar ampliamente en qué consiste el problema a resolver, cómo se resuelve, cómo y por qué se adoptó cierto diseño, cómo se optimizó y cómo se implementó en un lenguaje de programación."
  },
  {
    "objectID": "08-quarto.html#anatomía-de-un-documento-quarto",
    "href": "08-quarto.html#anatomía-de-un-documento-quarto",
    "title": "8  Quarto - sistema de publicación técnica y científica",
    "section": "8.4 Anatomía de un documento Quarto",
    "text": "8.4 Anatomía de un documento Quarto\nUn documento Quarto tiene tres tipos de contenido:\n\nMetadatos en YAML.\nNarrativa en Markdown.\nBloques de código fuente.\n\n\n8.4.1 Metadatos en YAML\nTodo documento Quarto inicia con un encabezado en la sintaxis YAML (YAML Ain’t Markup Language), el cual contiene metadatos del documento como el título, el autor, la fecha de creación, el formato de salida y la estructura de la tabla de contenidos, entre muchos otros.\nUn encabezado YAML comienza y termina con tres guiones (---) y contiene un conjunto de campos y valores de la forma:\n---\ncampo01: valor01\ncampo02: valor02\ncampo0n: valor0n\n---\nPor ejemplo, un encabezado YAML típico puede ser el siguiente:\n---\ntitle: Mi primer documento Quarto\nformat:\n  html:\n    toc: true\n    toc_float: true\n---\nLos campos del encabezado que dependen de otros campos se anidan con sangrías de dos espacios.\nLos elementos de metadatos que pueden especificarse en el encabezado, pueden variar de acuerdo al formato de salida, como puede verse en los siguientes enlaces:\n\nElementos de metadatos para HTML\nElementos de metadatos para PDF\nElementos metadatos para MS Word\n\nExisten elementos de metadatos para muchos otros formatos de salida (OpenOffice, ePub, presentaciones, wikis, etc.), como puede apreciarse en la Referencia de Quarto.\n\n\n8.4.2 Narrativa en Markdown\nLa narrativa proporciona estructura y contenido al documento en la forma de encabezados, párrafos, enlaces y otros elementos de la sintaxis de Markdown.\n\n\n8.4.3 Bloques de código fuente\nEn Quarto, los bloques (chunks) de código fuente se delimitan con tres backticks, tanto al inicio como al final del bloque. Los bloques de código en R se identifican con {r} y diferentes opciones identificadas con #|. Los bloques de otros lenguajes de programación se identifican con {python} y {julia}, por ejemplo.\nEl siguiente es un ejemplo de bloque de código en R y su salida:\n```{r}\n#| label: graficacion-cars\n#| include: true\n#| echo: false\n\nplot(\n  x = cars$speed,\n  y = cars$dist,\n  main = \"Velocidad vs distancia de frenado\",\n  xlab = \"Velocidad (MPH)\",\n  ylab = \"Distancia (pies)\"\n)\n```\n\n\n\n\n\nLa opción label se utiliza para etiquetar el bloque y la de include para especificar si se desea que el bloque y sus resultados se incluyan en el documento de salida."
  },
  {
    "objectID": "08-quarto.html#cómo-funciona-quarto",
    "href": "08-quarto.html#cómo-funciona-quarto",
    "title": "8  Quarto - sistema de publicación técnica y científica",
    "section": "8.5 ¿Cómo funciona Quarto?",
    "text": "8.5 ¿Cómo funciona Quarto?\nQuarto se apoya en knitr y en Pandoc. knitr ejecuta el código en R (u otro lenguaje) y convierte los documentos a Markdown. Por su parte, Pandoc exporta los documentos Markdown al formato de salida deseado (ej. HTML, PDF, MS Word, MS PowerPoint). Este proceso se ilustra en la Figura 8.1.\n\n\n\n\n\nFigura 8.1: Conversión de un documento Quarto (.qmd) a su formato de salida. Imagen de quarto.org."
  },
  {
    "objectID": "08-quarto.html#ejercicios",
    "href": "08-quarto.html#ejercicios",
    "title": "8  Quarto - sistema de publicación técnica y científica",
    "section": "8.6 Ejercicios",
    "text": "8.6 Ejercicios\nCon R y Quarto, cree un sitio web en GitHub Pages que contenga visualizaciones de los datos de homicidios ocurridos en Costa Rica en 2022, de acuerdo con las estadísticas publicadas en el sitio de datos abiertos del Organismo de Investigación Judicial (OIJ).\nSeguidamente, se sugiere una serie de pasos para elaborar el sitio. Puede encontrar el código fuente de una solución parcial en https://github.com/gf0604-procesamientodatosgeograficos/2023-i-delitos-graficosbase.\n\nCree un repositorio vacío en su cuenta en GitHub (ej. delitos-graficosbase).\nClone el nuevo repositorio en su computadora con la opción File - New Project - Version Control - Git de RStudio.\nCopie en el repositorio clonado el archivo CSV con los datos de delitos.\nCree un nuevo documento Quarto con la opción File - New File - Quarto Document de RStudio. Llene los metadatos (título, autor, etc.). Elija HTML como formato de salida.\nGuarde el documento en el repositorio clonado, con el nombre index.qmd (RStudio asigna la extensión automáticamente).\nAl inicio del documento, agregue texto Markdown que explique su contenido, la fuente de los datos y la dirección del repositorio en GitHub con el código fuente.\nEn un bloque de código en R, cargue el archivo CSV en un dataframe. Se recomienda asignar una etiqueta al bloque con la opción #| label:. Considere el uso de otras etiquetas Quarto para, por ejemplo, controlar el despliegue de las salidas y del código fuente. Despliegue una muestra de los datos en una tabla.\nEscriba bloques adicionales de código en R que generen los siguientes gráficos (en cada uno, agregue título, fuente y procure que luzca bien mediante colores, tamaños de letras y otros elementos estéticos):\n\nCantidad de delitos por provincia.\n\nGráfico de barras verticales.\nGráfico de barras horizontales.\nGráfico de pastel.\n\nCantidad de delitos por cantón en los 20 cantones con más delitos - gráfico de barras (verticales u horizontales).\nCantidad de delitos por edad de la víctima - gráfico de pastel.\nCantidad de delitos por provincia y edad de la víctima (una barra por provincia con colores según las edades) - gráfico de barras apiladas.\nCantidad de homicidios por provincia y edad de la víctima (una barra por provincia con colores según las edades) - gráfico de barras apiladas.\nCantidad de homicidios por cantón y edad de la víctima en los 20 cantones con más homicidios (una barra por provincia con colores según las edades) - gráfico de barras apiladas.\n\nPresione el botón Render de RStudio para generar el archivo index.html. Este será el arhivo que se desplegará en GitHub Pages.\nSincronice el repositorio local con el repositorio en GitHub, ya sea con comandos de Git o subiendo manualmente los archivos. Si lo hace manualmente, asegúrese de actualizar:\n\nEl documento HTML (index.html).\nEl documento Quarto (index.qmd).\nEl archivo CSV (estadisticaspoliciales2022.csv).\nArchivos temporales (ej. directorio index_files).\n\nGenere el sitio en GitHub Pages con la opción Settings - Pages de GitHub.\nRepita los pasos del 8 al 10 para cada modificación que realice en el documento Quarto."
  },
  {
    "objectID": "09-tidyverse.html",
    "href": "09-tidyverse.html",
    "title": "9  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "",
    "text": "Tidyverse es una colección de paquetes de R orientados a ciencia de datos y que apoya los procesos de importación, organización, transformación, visualización, modelado y comunicación.\nLos paquetes de Tidyverse trabajan con datos tidy (i.e. ordenados, organizados), los cuales deben cumplir con tres características:\n\nCada variable debe tener su propia columna.\nCada observación debe tener su propia fila.\nCada valor debe tener su propia celda.\n\nLas funciones de Tidyverse pueden encadenarse a través del operador pipe (tubo), ya sea el del paquete magrittr (%>%) o el del paquete base de R (|>). Los procesos se enlazan con pipes para formar pipelines (tuberías). En este contexto, un pipeline consiste de una cadena de procesos conectados de forma tal que la salida de cada proceso de la cadena es la entrada del próximo. Esto permite la comunicación y sincronización entre los procesos y evita la anidación de funciones."
  },
  {
    "objectID": "09-tidyverse.html#trabajo-previo",
    "href": "09-tidyverse.html#trabajo-previo",
    "title": "9  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "9.2 Trabajo previo",
    "text": "9.2 Trabajo previo\n\n9.2.1 Lecturas\nWickham, H., & Grolemund, G. (2017). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (1st ed.). O’Reilly Media. https://r4ds.had.co.nz/\nWickham, H., & Grolemund, G. (s. f.). R para Ciencia de Datos (1era ed.). Recuperado 14 de mayo de 2022, de https://es.r4ds.hadley.nz/\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (s. f.). R for Data Science (2nd ed.). Recuperado 16 de octubre de 2022, de https://r4ds.hadley.nz/"
  },
  {
    "objectID": "09-tidyverse.html#introducción",
    "href": "09-tidyverse.html#introducción",
    "title": "9  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "9.3 Introducción",
    "text": "9.3 Introducción\nTidyverse es una colección de paquetes de R enfocados en ciencia de datos, una discipina que permite convertir datos no procesados en entendimiento, comprensión y conocimiento.\nLa Figura 9.1 ilustra el modelo de un proyecto típico de ciencia de datos, el cual incluye los procesos de importar, ordenar, transformar, visualizar, modelar y comunicar. Todos se articulan mediante programación de computadoras.\n\n\n\n\n\nFigura 9.1: Modelo de ciencia de datos. Imagen de Hadley Wickham.\n\n\n\n\n\nImportar los datos típicamente implica leerlos de un archivo, una base de datos o una interfaz de programación de aplicaciones (API) y cargarlos en un data frame.\nOrdenar u organizar (to tidy) los datos significa colocarlos en estructuras rectangulares de filas y columnas, similares a tablas, de manera que cada fila sea una observación y cada columna una variable.\nTransformar los datos implica la generación de algún subconjunto de filas y columnas, la creación de nuevas variables o el cálculo de estadísticas (ej. conteos, promedios, mínimos, máximos).\nVisualizar los datos (en tablas, gráficos, mapas, etc.) permite encontrar patrones inesperados o formular nuevas preguntas.\nModelar es crear una representación abstracta y estructurada de los datos, con el fin de facilitar su análisis y realizar predicciones.\nComunicar es el último paso y es una actividad crítica de cualquier proyecto de análisis de datos o de ciencia en general.\n\nLos paquetes de Tidyverse comparten filosofía de diseño, gramática y estructuras de datos para apoyar estos procesos del modelo de ciencia de datos. El concepto de Tidyverse fue introducido por Hadley Wickham, quien también ha programado varios de sus paquetes."
  },
  {
    "objectID": "09-tidyverse.html#paquetes",
    "href": "09-tidyverse.html#paquetes",
    "title": "9  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "9.4 Paquetes",
    "text": "9.4 Paquetes\nEl núcleo de Tidyverse está compuesto por ocho paquetes base, los cuales proveen las funcionalidades utilizadas más frecuentemente en análisis de datos:\n\ndplyr: gramática para la manipulación de datos que proporciona un conjunto consistente de “verbos” que resulven los retos más comunes de manipulación de datos.\nggplot2: sistema para la creación declarativa de gráficos, basado en el libro The Grammar of Graphics, de Wilkinson et al..\ntidyr: conjunto de funciones para organizar (to tidy) datos, colocando las observaciones, variables y valores en filas, columnas y celdas de estructuras rectangulares.\nreadr: conjunto de funciones para cargar datos de estructuras rectangulares (ej. archivos CSV) en memoria.\npurr: conjunto de herramientas de programación funcional para trabajar con funciones y vectores.\ntibble: un tibble es una redefinición del concepto de data frame, para hacerlos más eficientes y fáciles de usar.\nstringr: colección de funciones para facilitar el trabajo con hileras de caracteres.\nforcats: colección de funciones para facilitar el trabajo con factores.\n\nHay otros paquetes para tareas más especifícas relacionadas con importación, limpieza y modelado de datos, entre otras. Los paquetes de Tidyverse son de los más descargados, entre la totalidad de paquetes del lenguaje de programación R."
  },
  {
    "objectID": "09-tidyverse.html#instalación-y-carga",
    "href": "09-tidyverse.html#instalación-y-carga",
    "title": "9  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "9.5 Instalación y carga",
    "text": "9.5 Instalación y carga\nLos paquetes de Tidyverse pueden instalarse con la función install.packages(), ya sea de manera conjunta (todos los paquetes básicos) o individualmente:\n\n# Instalación conjunta (toma más tiempo)\ninstall.packages(\"tidyverse\")\n\n# Instalación de paquetes individuales\ninstall.packages(\"ggplot2\")\ninstall.packages(\"dplyr\")\n\nUna vez instalados, los paquetes también pueden cargarse conjunta o separadamente con la función library():\n\n# Carga conjunta\nlibrary(tidyverse)\n\n# Carga de paquetes individuales\nlibrary(ggplot2)\nlibrary(dplyr)\n\nTambién es posible utilizar la notación paquete::funcion() para llamar una función sin necesidad de cargar todo el paquete (siempre y cuando este haya sido instalado):\n\n# Llamado a la función glimpse() del paquete dplyr\ndplyr::glimpse(iris)\n\nRows: 150\nColumns: 5\n$ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.…\n$ Sepal.Width  <dbl> 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.…\n$ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.…\n$ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.…\n$ Species      <fct> setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…"
  },
  {
    "objectID": "09-tidyverse.html#el-conjunto-de-datos-palmerpenguins",
    "href": "09-tidyverse.html#el-conjunto-de-datos-palmerpenguins",
    "title": "9  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "9.6 El conjunto de datos palmerpenguins",
    "text": "9.6 El conjunto de datos palmerpenguins\npalmerpenguins es un paquete de datos de R ampliamente utilizado para ejemplificar funciones de exploración y visualización, como las de Tidyverse. Es muy popular en ciencia de datos en general y también está disponible para otros lenguajes de programación (ej. Python, Julia). Se utiliza como una alternativa a otros conjuntos de datos usualmente usados para ejemplos como, por ejemplo, iris.\nLos datos de palmerpenguins fueron recolectados entre 2007 y 2009 por la Dr. Kristen Gorman y el Programa de Investigación Ecológica de Largo Plazo (LTER) de la Estación Palmer. Consisten de 344 observaciones de pingüinos de tres especies, las cuales habitan en tres islas del archipiélago Palmer, en la Antártida. Para cada individuo se registraron variables como especie, sexo, masa (peso), longitud de la aleta (flipper), longitud del pico (bill) y profundidad del pico, entre otras.\nEn R, el paquete puede instalarse con la función install.packages():\n\n# Instalación de palmerpenguins\ninstall.packages(\"palmerpenguins\")\n\nUna vez instalado, el paquete puede cargarse con la función library():\n\n# Carga de palmerpenguins\nlibrary(palmerpenguins)\n\nEl paquete contiene dos conjuntos de datos:\n\npenguins_raw: datos sin procesar.\npenguins: subconjunto curado de los datos sin procesar.\n\npalmerpinguins se utilizará en este capítulo, y en los siguientes, para ejemplificar varias de las funcionalidades de Tidyverse.\n\n9.6.1 Ejemplos de visualizaciones\nSeguidamente se muestran varios tipos de gráficos estadísticos generados con la función ggplot() del paquete ggplot2.\n\n9.6.1.1 Gráficos de dispersión\nEste tipo de gráficos muestra relaciones entre variables.\n\n# Gráfico de dispersión de longitud del pico vs masa (peso)\npenguins |>\n  ggplot(aes(x = bill_length_mm, y = body_mass_g)) +\n  geom_point(size = 2) +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  ggtitle(\"Longitud del pico vs. masa\") +\n  xlab(\"Longitud del pico (mm)\") +\n  ylab(\"Masa (g)\") +\n  labs(color = \"Especie\", shape = \"Especie\")\n\n\n\n\n\n# Gráfico de dispersión de longitud del pico vs masa (peso) por especie\npenguins |>\n  ggplot(aes(x = bill_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species,\n                 shape = species),\n             size = 2) +\n  geom_smooth(method = \"lm\", se = FALSE, aes(color = species)) +\n  scale_color_manual(values = c(\"darkorange\", \"darkorchid\", \"cyan4\")) +\n  ggtitle(\"Longitud del pico vs. masa por especie\") +\n  xlab(\"Longitud del pico (mm)\") +\n  ylab(\"Masa (g)\") +\n  labs(color = \"Especie\", shape = \"Especie\")\n\n\n\n\n\n\n9.6.1.2 Histogramas\nEste tipo de gráficos muestra distribuciones de variables numéricas.\n\n# Distribución de la variable de masa (peso)\npenguins |>\n  ggplot(aes(x = body_mass_g)) +\n  geom_histogram() +\n  ggtitle(\"Distribución de la variable masa (peso)\") +\n  xlab(\"Masa (g)\") +\n  ylab(\"n\")\n\n\n\n\n\n# Distribución de la variable de masa (peso) por especie\npenguins |>\n  ggplot(aes(x = body_mass_g)) +\n  geom_histogram(aes(fill = species), alpha = 0.5, position = \"identity\") +\n  scale_fill_manual(values = c(\"darkorange\", \"darkorchid\", \"cyan4\")) +\n  ggtitle(\"Distribución de la variable masa (peso) por especie\") +\n  xlab(\"Masa (g)\") +\n  ylab(\"n\") +\n  labs(fill = \"Especie\")\n\n\n\n\n\n\n9.6.1.3 Diagramas de caja\nEste tipo de gráficos muestra datos a través de sus cuartiles.\n\n# Diagrama de caja de la variable masa (peso)\npenguins |>\n  ggplot(aes(y = body_mass_g)) +\n  geom_boxplot() +\n  ylab(\"Masa (g)\")\n\n\n\n\n\n# Diagrama de caja de la variable masa (peso) por especie\npenguins |>\n  ggplot(aes(x = species, y = body_mass_g)) +\n  geom_boxplot(aes(color = species), width = 0.3, show.legend = FALSE) +\n  scale_color_manual(values = c(\"darkorange\", \"purple\", \"cyan4\")) +\n  xlab(\"Especie\") +\n  ylab(\"Masa (g)\")"
  },
  {
    "objectID": "09-tidyverse.html#datos-tidy",
    "href": "09-tidyverse.html#datos-tidy",
    "title": "9  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "9.7 Datos tidy",
    "text": "9.7 Datos tidy\nLos paquetes de Tidyverse trabajan con datos tidy (i.e. ordenados, organizados), un concepto también introducido por Hadley Wickham y que está relacionado con la organización de los datos en estructuras rectangulares de filas y columnas, similares a las tablas o matrices.\nSegún Wickham, los datos tidy deben cumplir con tres características:\n\nCada variable debe tener su propia columna.\nCada observación debe tener su propia fila.\nCada valor debe tener su propia celda.\n\nEstas características se ilustran en la Figura 9.2.\n\n\n\n\n\nFigura 9.2: Datos tidy. Imagen de Hadley Wickham.\n\n\n\n\nEl empleo de este modelo de datos es común en todos los paquetes de Tidyverse, lo que posibilita aprender y usar sus funciones con mayor facilidad. Además, permite invertir menos esfuerzo en lidiar con diferentes modelos de datos y así dedicar más tiempo y esfuerzo en los problemas de análisis a resolver."
  },
  {
    "objectID": "09-tidyverse.html#pipes",
    "href": "09-tidyverse.html#pipes",
    "title": "9  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "9.8 Pipes",
    "text": "9.8 Pipes\nLas funciones de Tidyverse pueden encadenarse a través del operador pipe (tubo), ya sea el del paquete magrittr (%>%) o el del paquete base de R (|>). Los procesos se enlazan con pipes para formar pipelines (tuberías). En este contexto, un pipeline consiste de una cadena de procesos conectados de forma tal que la salida de cada proceso de la cadena es la entrada del próximo. Esto permite la comunicación y sincronización entre los procesos y evita la anidación (nesting) de llamados a funciones.\nEl siguiente ejemplo implementa un pipeline de dos funciones de Tidyverse:\n\n# Cadena de \"pipes\" entre funciones de Tidyverse\npenguins |>\n  dplyr::filter(species == \"Gentoo\") %>% # subconjunto de observaciones\n  select(species, bill_length_mm, flipper_length_mm) # subconjunto de columnas\n\n# A tibble: 124 × 3\n   species bill_length_mm flipper_length_mm\n   <fct>            <dbl>             <int>\n 1 Gentoo            46.1               211\n 2 Gentoo            50                 230\n 3 Gentoo            48.7               210\n 4 Gentoo            50                 218\n 5 Gentoo            47.6               215\n 6 Gentoo            46.5               210\n 7 Gentoo            45.4               211\n 8 Gentoo            46.7               219\n 9 Gentoo            43.3               209\n10 Gentoo            46.8               215\n# ℹ 114 more rows\n\n\nUna alternativa a los pipes es la anidación de llamados a funciones:\n\n# Llamados anidados a funciones\nselect(filter(penguins, species == \"Gentoo\"),\n       species,\n       bill_length_mm,\n       flipper_length_mm)\n\n# A tibble: 124 × 3\n   species bill_length_mm flipper_length_mm\n   <fct>            <dbl>             <int>\n 1 Gentoo            46.1               211\n 2 Gentoo            50                 230\n 3 Gentoo            48.7               210\n 4 Gentoo            50                 218\n 5 Gentoo            47.6               215\n 6 Gentoo            46.5               210\n 7 Gentoo            45.4               211\n 8 Gentoo            46.7               219\n 9 Gentoo            43.3               209\n10 Gentoo            46.8               215\n# ℹ 114 more rows\n\n\nEl uso de pipes permite un funcionamiento homogéneo de las funciones de Tidyverse:\n\nEl primer argumento es un data frame. Puede omitirse si la función recibe el data frame a través del operador pipe.\nLos argumentos siguientes describen que hacer con el data frame, utilizando los nombres de las columnas (sin comillas).\n\nEl resultado es un nuevo data frame."
  },
  {
    "objectID": "09-tidyverse.html#recursos-de-interés",
    "href": "09-tidyverse.html#recursos-de-interés",
    "title": "9  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "9.9 Recursos de interés",
    "text": "9.9 Recursos de interés\nCanelón, S. (s.f.). Slides | Silvia Canelón—An Antarctic Tour of the Tidyverse. Recuperado 16 de octubre de 2022, de https://slides.silviacanelon.com/tour-of-the-tidyverse-v2/#/title-slide\nWickham, H. (2014). Tidy Data. Journal of Statistical Software, 59(1), 1-23. https://doi.org/10.18637/jss.v059.i10"
  },
  {
    "objectID": "parte-vi-evaluaciones.html",
    "href": "parte-vi-evaluaciones.html",
    "title": "Evaluaciones",
    "section": "",
    "text": "Examen corto 1"
  },
  {
    "objectID": "parte-vi-evaluaciones.html#tareas",
    "href": "parte-vi-evaluaciones.html#tareas",
    "title": "Evaluaciones",
    "section": "Tareas",
    "text": "Tareas\nTarea 1"
  },
  {
    "objectID": "examen_corto-01.html",
    "href": "examen_corto-01.html",
    "title": "Examen corto 1",
    "section": "",
    "text": "Grupo 001: martes 28 de marzo de 2023\nGrupo 002: jueves 30 de marzo de 2023"
  },
  {
    "objectID": "examen_corto-01.html#temas-a-evaluar",
    "href": "examen_corto-01.html#temas-a-evaluar",
    "title": "Examen corto 1",
    "section": "Temas a evaluar",
    "text": "Temas a evaluar\n1 Pensamiento computacional, arquitectura de computadoras y lenguajes de programación\n2 Interacción humano-computadora\n3 GDAL - biblioteca para lectura y escritura de datos geoespaciales con interfaz de línea de comandos"
  },
  {
    "objectID": "tarea-01.html",
    "href": "tarea-01.html",
    "title": "Tarea 1",
    "section": "",
    "text": "Martes 18 de abril de 2023, 07:59 a.m.\n\n\n\nMiércoles 19 de abril de 2023, 10:59 a.m."
  },
  {
    "objectID": "tarea-01.html#objetivos",
    "href": "tarea-01.html#objetivos",
    "title": "Tarea 1",
    "section": "Objetivos",
    "text": "Objetivos\nCada estudiante debe mostrar que es capaz de:\n\nEscribir documentos en el lenguaje de marcado Markdown.\nManejar repositorios en GitHub.\nPublicar repositorios en GitHub como sitios web en GitHub Pages."
  },
  {
    "objectID": "tarea-01.html#entregables",
    "href": "tarea-01.html#entregables",
    "title": "Tarea 1",
    "section": "Entregables",
    "text": "Entregables\n\nDirección de un repositorio en GitHub (ej. https://github.com/mfvargas/tarea-01) que contenga un documento escrito en Markdown llamado README.md, con el contenido especificado en la sección Desarrollo.\nDirección de un sitio web publicado en GitHub Pages generado a partir del repositorio especificado en el punto anterior (ej. https://mfvargas.github.io/tarea-01/). Se recomienda usar un nombre más significativo que tarea-01 para el repositorio, acorde con su contenido.\n\nLa entrega debe realizarse a través de la plataforma Mediación Virtual."
  },
  {
    "objectID": "tarea-01.html#consideraciones-adicionales",
    "href": "tarea-01.html#consideraciones-adicionales",
    "title": "Tarea 1",
    "section": "Consideraciones adicionales",
    "text": "Consideraciones adicionales\nEsta tarea es estrictamente individual."
  },
  {
    "objectID": "tarea-01.html#desarrollo",
    "href": "tarea-01.html#desarrollo",
    "title": "Tarea 1",
    "section": "Desarrollo",
    "text": "Desarrollo\nDebe desarrollar con Markdown un sitio web sobre un tema de su elección (un adelanto del trabajo final de graduación, alguna temática tratada en otro curso, un proyecto personal, etc.). El sitio debe contener, como mínimo, los siguientes elementos:\n\nEncabezados: por lo menos de niveles uno y dos.\nTexto: por lo menos 500 palabras.\nNegritas: por lo menos dos palabras.\nItálicas: por lo menos dos palabras.\nListas: al menos una, ya sea numerada o no numerada.\nImágenes: al menos dos, una local (en el repositorio GitHub de la tarea) y otra remota (de un sitio web externo).\nHipervínculos: al menos dos.\n\nPuede utilizar imágenes de fuentes externas, pero debe dar los créditos apropiados y proporcionar, al menos, un enlace al origen. En el texto, puede apoyarse en fuentes externas, pero debe incluir las citas bibliográficas. No debe “copiar y pegar” texto u otros contenidos.\nEl contenido del sitio debe ser coherente y estar bien presentado."
  },
  {
    "objectID": "tarea-01.html#calificación",
    "href": "tarea-01.html#calificación",
    "title": "Tarea 1",
    "section": "Calificación",
    "text": "Calificación\nDirecciones entregadas:\n- Dirección del repositorio en GitHub: 10%\n- Dirección del sitio web publicado en GitHub Pages: 10%\nComponentes del documento escrito en Markdown:\n- Encabezados: 5%\n- Texto: 15%\n- Negritas: 5%\n- Itálicas: 5%\n- Listas: 10%\n- Imágenes: 20%\n- Hipervínculos: 10%\nCoherencia y presentación general del sitio web: 10%"
  }
]